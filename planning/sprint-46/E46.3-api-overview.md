# E46.3 - API Overview

## Resumo

Criar o endpoint de API que retorna os KPIs e metricas de overview do Market Intelligence.

## Contexto

Este endpoint sera a fonte de dados principal para o dashboard de overview, fornecendo KPIs com variacao temporal e dados para sparklines.

## Escopo

### Incluido
- Route handler `/api/market-intelligence/overview`
- Validacao de parametros com Zod
- Queries otimizadas ao banco
- Tratamento de erros
- Testes de integracao

### Excluido
- Cache Redis (sera adicionado depois)
- Autenticacao (usa middleware existente)

---

## Especificacao Tecnica

### Endpoint

```
GET /api/market-intelligence/overview
```

### Query Parameters

| Parametro | Tipo | Obrigatorio | Default | Descricao |
|-----------|------|-------------|---------|-----------|
| period | string | Nao | '30d' | Periodo: '7d', '30d', '90d', 'custom' |
| startDate | string | Se custom | - | Data inicio (ISO: YYYY-MM-DD) |
| endDate | string | Se custom | - | Data fim (ISO: YYYY-MM-DD) |

### Response

```typescript
// 200 OK
{
  "periodo": {
    "inicio": "2024-01-01",
    "fim": "2024-01-31",
    "dias": 31
  },
  "kpis": {
    "gruposAtivos": {
      "valor": 50,
      "valorFormatado": "50",
      "variacao": 10.5,
      "variacaoTipo": "up",
      "tendencia": [45, 47, 48, 49, 50]
    },
    "vagasPorDia": { ... },
    "taxaConversao": { ... },
    "valorMedio": { ... }
  },
  "resumo": {
    "totalMensagens": 5000,
    "totalOfertas": 500,
    "totalVagasExtraidas": 400,
    "totalVagasImportadas": 260
  },
  "updatedAt": "2024-01-31T12:00:00Z"
}

// 400 Bad Request
{
  "error": "VALIDATION_ERROR",
  "message": "Parametros invalidos",
  "details": {
    "period": "Valor invalido. Use: 7d, 30d, 90d ou custom"
  }
}

// 500 Internal Server Error
{
  "error": "DATABASE_ERROR",
  "message": "Erro ao consultar banco de dados"
}
```

---

## Implementacao

### Arquivo: `dashboard/app/api/market-intelligence/overview/route.ts`

```typescript
/**
 * API Market Intelligence Overview - Sprint 46
 *
 * Retorna KPIs e metricas de overview do modulo de Market Intelligence.
 */

import { NextRequest, NextResponse } from 'next/server'
import { z } from 'zod'
import { createClient } from '@/lib/supabase/server'
import {
  type MarketOverviewResponse,
  type KPIMetric,
  type AnalyticsPeriod,
} from '@/types/market-intelligence'

// =============================================================================
// VALIDACAO
// =============================================================================

const querySchema = z.object({
  period: z.enum(['7d', '30d', '90d', 'custom']).default('30d'),
  startDate: z.string().regex(/^\d{4}-\d{2}-\d{2}$/).optional(),
  endDate: z.string().regex(/^\d{4}-\d{2}-\d{2}$/).optional(),
}).refine(
  (data) => {
    if (data.period === 'custom') {
      return data.startDate && data.endDate
    }
    return true
  },
  {
    message: 'startDate e endDate sao obrigatorios quando period=custom',
  }
)

// =============================================================================
// HELPERS
// =============================================================================

/**
 * Calcula as datas de inicio e fim baseado no periodo
 */
function calcularPeriodo(
  period: AnalyticsPeriod,
  startDate?: string,
  endDate?: string
): { inicio: Date; fim: Date; dias: number } {
  const fim = endDate ? new Date(endDate) : new Date()
  fim.setHours(23, 59, 59, 999)

  let inicio: Date

  switch (period) {
    case '7d':
      inicio = new Date(fim)
      inicio.setDate(inicio.getDate() - 6)
      break
    case '30d':
      inicio = new Date(fim)
      inicio.setDate(inicio.getDate() - 29)
      break
    case '90d':
      inicio = new Date(fim)
      inicio.setDate(inicio.getDate() - 89)
      break
    case 'custom':
      inicio = new Date(startDate!)
      break
    default:
      inicio = new Date(fim)
      inicio.setDate(inicio.getDate() - 29)
  }

  inicio.setHours(0, 0, 0, 0)

  const dias = Math.ceil((fim.getTime() - inicio.getTime()) / (1000 * 60 * 60 * 24)) + 1

  return { inicio, fim, dias }
}

/**
 * Calcula variacao percentual entre dois valores
 */
function calcularVariacao(atual: number, anterior: number): {
  variacao: number | null
  variacaoTipo: 'up' | 'down' | 'stable' | null
} {
  if (anterior === 0) {
    return { variacao: null, variacaoTipo: null }
  }

  const variacao = ((atual - anterior) / anterior) * 100

  let variacaoTipo: 'up' | 'down' | 'stable'
  if (variacao > 1) {
    variacaoTipo = 'up'
  } else if (variacao < -1) {
    variacaoTipo = 'down'
  } else {
    variacaoTipo = 'stable'
  }

  return { variacao: Math.round(variacao * 10) / 10, variacaoTipo }
}

/**
 * Formata valor monetario (centavos para reais)
 */
function formatarValor(centavos: number): string {
  return new Intl.NumberFormat('pt-BR', {
    style: 'currency',
    currency: 'BRL',
    minimumFractionDigits: 0,
  }).format(centavos / 100)
}

// =============================================================================
// QUERIES
// =============================================================================

interface MetricasPeriodo {
  gruposAtivos: number
  mensagensTotal: number
  mensagensComOferta: number
  vagasExtraidas: number
  vagasImportadas: number
  valorMedio: number | null
  tendenciaGrupos: number[]
  tendenciaVagas: number[]
  tendenciaTaxa: number[]
  tendenciaValor: number[]
}

async function buscarMetricasPeriodo(
  supabase: ReturnType<typeof createClient>,
  inicio: Date,
  fim: Date
): Promise<MetricasPeriodo> {
  // Query principal - metricas agregadas
  const { data: metricas, error: erroMetricas } = await supabase
    .from('market_intelligence_daily')
    .select('*')
    .gte('data', inicio.toISOString().split('T')[0])
    .lte('data', fim.toISOString().split('T')[0])
    .order('data', { ascending: true })

  if (erroMetricas) {
    throw new Error(`Erro ao buscar metricas: ${erroMetricas.message}`)
  }

  // Se nao houver dados na tabela de snapshots, buscar diretamente
  if (!metricas || metricas.length === 0) {
    return await buscarMetricasDireto(supabase, inicio, fim)
  }

  // Agregar metricas
  const totais = metricas.reduce(
    (acc, m) => ({
      gruposAtivos: Math.max(acc.gruposAtivos, m.grupos_ativos || 0),
      mensagensTotal: acc.mensagensTotal + (m.mensagens_total || 0),
      mensagensComOferta: acc.mensagensComOferta + (m.mensagens_com_oferta || 0),
      vagasExtraidas: acc.vagasExtraidas + (m.vagas_extraidas || 0),
      vagasImportadas: acc.vagasImportadas + (m.vagas_importadas || 0),
      valoresPlantao: [...acc.valoresPlantao, m.valor_medio_plantao].filter(Boolean),
    }),
    {
      gruposAtivos: 0,
      mensagensTotal: 0,
      mensagensComOferta: 0,
      vagasExtraidas: 0,
      vagasImportadas: 0,
      valoresPlantao: [] as number[],
    }
  )

  // Calcular valor medio
  const valorMedio =
    totais.valoresPlantao.length > 0
      ? Math.round(
          totais.valoresPlantao.reduce((a, b) => a + b, 0) / totais.valoresPlantao.length
        )
      : null

  // Extrair tendencias (ultimos 5 pontos)
  const ultimosN = metricas.slice(-5)
  const tendenciaGrupos = ultimosN.map((m) => m.grupos_ativos || 0)
  const tendenciaVagas = ultimosN.map((m) => m.vagas_importadas || 0)
  const tendenciaTaxa = ultimosN.map((m) =>
    m.taxa_importacao ? Math.round(m.taxa_importacao * 100) : 0
  )
  const tendenciaValor = ultimosN.map((m) => m.valor_medio_plantao || 0)

  return {
    gruposAtivos: totais.gruposAtivos,
    mensagensTotal: totais.mensagensTotal,
    mensagensComOferta: totais.mensagensComOferta,
    vagasExtraidas: totais.vagasExtraidas,
    vagasImportadas: totais.vagasImportadas,
    valorMedio,
    tendenciaGrupos,
    tendenciaVagas,
    tendenciaTaxa,
    tendenciaValor,
  }
}

async function buscarMetricasDireto(
  supabase: ReturnType<typeof createClient>,
  inicio: Date,
  fim: Date
): Promise<MetricasPeriodo> {
  const inicioStr = inicio.toISOString()
  const fimStr = fim.toISOString()

  // Buscar de tabelas originais
  const [gruposRes, mensagensRes, vagasRes] = await Promise.all([
    // Grupos ativos
    supabase
      .from('grupos_whatsapp')
      .select('id', { count: 'exact', head: true })
      .eq('ativo', true),

    // Mensagens
    supabase
      .from('mensagens_grupo')
      .select('id, eh_oferta', { count: 'exact' })
      .gte('created_at', inicioStr)
      .lte('created_at', fimStr),

    // Vagas
    supabase
      .from('vagas_grupo')
      .select('id, status, valor')
      .gte('created_at', inicioStr)
      .lte('created_at', fimStr),
  ])

  const gruposAtivos = gruposRes.count || 0
  const mensagens = mensagensRes.data || []
  const vagas = vagasRes.data || []

  const mensagensTotal = mensagens.length
  const mensagensComOferta = mensagens.filter((m) => m.eh_oferta).length
  const vagasExtraidas = vagas.length
  const vagasImportadas = vagas.filter((v) => v.status === 'importada').length

  const valoresValidos = vagas
    .filter((v) => v.valor && v.valor > 0)
    .map((v) => v.valor as number)
  const valorMedio =
    valoresValidos.length > 0
      ? Math.round(valoresValidos.reduce((a, b) => a + b, 0) / valoresValidos.length)
      : null

  return {
    gruposAtivos,
    mensagensTotal,
    mensagensComOferta,
    vagasExtraidas,
    vagasImportadas,
    valorMedio,
    tendenciaGrupos: [gruposAtivos],
    tendenciaVagas: [vagasImportadas],
    tendenciaTaxa: [vagasExtraidas > 0 ? Math.round((vagasImportadas / vagasExtraidas) * 100) : 0],
    tendenciaValor: [valorMedio || 0],
  }
}

// =============================================================================
// HANDLER
// =============================================================================

export async function GET(request: NextRequest) {
  try {
    // 1. Validar parametros
    const searchParams = Object.fromEntries(request.nextUrl.searchParams)
    const validacao = querySchema.safeParse(searchParams)

    if (!validacao.success) {
      return NextResponse.json(
        {
          error: 'VALIDATION_ERROR',
          message: 'Parametros invalidos',
          details: validacao.error.flatten().fieldErrors,
        },
        { status: 400 }
      )
    }

    const { period, startDate, endDate } = validacao.data

    // 2. Calcular periodo
    const { inicio, fim, dias } = calcularPeriodo(period, startDate, endDate)

    // 3. Calcular periodo anterior (para variacao)
    const diasPeriodo = dias
    const inicioAnterior = new Date(inicio)
    inicioAnterior.setDate(inicioAnterior.getDate() - diasPeriodo)
    const fimAnterior = new Date(inicio)
    fimAnterior.setDate(fimAnterior.getDate() - 1)

    // 4. Buscar dados
    const supabase = createClient()

    const [metricasAtuais, metricasAnteriores] = await Promise.all([
      buscarMetricasPeriodo(supabase, inicio, fim),
      buscarMetricasPeriodo(supabase, inicioAnterior, fimAnterior),
    ])

    // 5. Calcular KPIs
    const vagasPorDia = dias > 0 ? metricasAtuais.vagasImportadas / dias : 0
    const vagasPorDiaAnterior =
      diasPeriodo > 0 ? metricasAnteriores.vagasImportadas / diasPeriodo : 0

    const taxaConversao =
      metricasAtuais.vagasExtraidas > 0
        ? metricasAtuais.vagasImportadas / metricasAtuais.vagasExtraidas
        : 0
    const taxaConversaoAnterior =
      metricasAnteriores.vagasExtraidas > 0
        ? metricasAnteriores.vagasImportadas / metricasAnteriores.vagasExtraidas
        : 0

    // 6. Montar response
    const response: MarketOverviewResponse = {
      periodo: {
        inicio: inicio.toISOString().split('T')[0],
        fim: fim.toISOString().split('T')[0],
        dias,
      },
      kpis: {
        gruposAtivos: {
          valor: metricasAtuais.gruposAtivos,
          valorFormatado: String(metricasAtuais.gruposAtivos),
          ...calcularVariacao(metricasAtuais.gruposAtivos, metricasAnteriores.gruposAtivos),
          tendencia: metricasAtuais.tendenciaGrupos,
        },
        vagasPorDia: {
          valor: Math.round(vagasPorDia * 10) / 10,
          valorFormatado: `${(Math.round(vagasPorDia * 10) / 10).toFixed(1)}/dia`,
          ...calcularVariacao(vagasPorDia, vagasPorDiaAnterior),
          tendencia: metricasAtuais.tendenciaVagas,
        },
        taxaConversao: {
          valor: Math.round(taxaConversao * 1000) / 10,
          valorFormatado: `${(Math.round(taxaConversao * 1000) / 10).toFixed(1)}%`,
          ...calcularVariacao(taxaConversao, taxaConversaoAnterior),
          tendencia: metricasAtuais.tendenciaTaxa,
        },
        valorMedio: {
          valor: metricasAtuais.valorMedio || 0,
          valorFormatado: metricasAtuais.valorMedio
            ? formatarValor(metricasAtuais.valorMedio)
            : 'N/A',
          ...calcularVariacao(
            metricasAtuais.valorMedio || 0,
            metricasAnteriores.valorMedio || 0
          ),
          tendencia: metricasAtuais.tendenciaValor,
        },
      },
      resumo: {
        totalMensagens: metricasAtuais.mensagensTotal,
        totalOfertas: metricasAtuais.mensagensComOferta,
        totalVagasExtraidas: metricasAtuais.vagasExtraidas,
        totalVagasImportadas: metricasAtuais.vagasImportadas,
      },
      updatedAt: new Date().toISOString(),
    }

    return NextResponse.json(response)
  } catch (error) {
    console.error('[Market Intelligence Overview] Erro:', error)

    return NextResponse.json(
      {
        error: 'INTERNAL_ERROR',
        message: 'Erro interno ao processar requisicao',
      },
      { status: 500 }
    )
  }
}
```

---

## Testes

### Arquivo: `dashboard/__tests__/api/market-intelligence/overview.test.ts`

```typescript
/**
 * Testes de Integracao - API Market Intelligence Overview
 */

import { GET } from '@/app/api/market-intelligence/overview/route'
import { NextRequest } from 'next/server'
import { createClient } from '@/lib/supabase/server'

// Mock do Supabase
jest.mock('@/lib/supabase/server', () => ({
  createClient: jest.fn(),
}))

const mockSupabase = {
  from: jest.fn().mockReturnThis(),
  select: jest.fn().mockReturnThis(),
  gte: jest.fn().mockReturnThis(),
  lte: jest.fn().mockReturnThis(),
  eq: jest.fn().mockReturnThis(),
  order: jest.fn().mockReturnThis(),
}

describe('API /api/market-intelligence/overview', () => {
  beforeEach(() => {
    jest.clearAllMocks()
    ;(createClient as jest.Mock).mockReturnValue(mockSupabase)
  })

  describe('Validacao de Parametros', () => {
    it('deve aceitar request sem parametros (usa defaults)', async () => {
      mockSupabase.order.mockResolvedValue({ data: [], error: null })
      mockSupabase.eq.mockResolvedValue({ count: 10, error: null })
      mockSupabase.lte.mockResolvedValue({ data: [], error: null })

      const request = new NextRequest('http://localhost/api/market-intelligence/overview')
      const response = await GET(request)

      expect(response.status).toBe(200)
      const data = await response.json()
      expect(data.periodo.dias).toBe(30) // default period
    })

    it('deve aceitar period=7d', async () => {
      mockSupabase.order.mockResolvedValue({ data: [], error: null })
      mockSupabase.eq.mockResolvedValue({ count: 10, error: null })
      mockSupabase.lte.mockResolvedValue({ data: [], error: null })

      const request = new NextRequest(
        'http://localhost/api/market-intelligence/overview?period=7d'
      )
      const response = await GET(request)

      expect(response.status).toBe(200)
      const data = await response.json()
      expect(data.periodo.dias).toBe(7)
    })

    it('deve aceitar period=90d', async () => {
      mockSupabase.order.mockResolvedValue({ data: [], error: null })
      mockSupabase.eq.mockResolvedValue({ count: 10, error: null })
      mockSupabase.lte.mockResolvedValue({ data: [], error: null })

      const request = new NextRequest(
        'http://localhost/api/market-intelligence/overview?period=90d'
      )
      const response = await GET(request)

      expect(response.status).toBe(200)
      const data = await response.json()
      expect(data.periodo.dias).toBe(90)
    })

    it('deve rejeitar period invalido', async () => {
      const request = new NextRequest(
        'http://localhost/api/market-intelligence/overview?period=invalid'
      )
      const response = await GET(request)

      expect(response.status).toBe(400)
      const data = await response.json()
      expect(data.error).toBe('VALIDATION_ERROR')
    })

    it('deve rejeitar custom sem datas', async () => {
      const request = new NextRequest(
        'http://localhost/api/market-intelligence/overview?period=custom'
      )
      const response = await GET(request)

      expect(response.status).toBe(400)
      const data = await response.json()
      expect(data.error).toBe('VALIDATION_ERROR')
    })

    it('deve aceitar custom com datas validas', async () => {
      mockSupabase.order.mockResolvedValue({ data: [], error: null })
      mockSupabase.eq.mockResolvedValue({ count: 10, error: null })
      mockSupabase.lte.mockResolvedValue({ data: [], error: null })

      const request = new NextRequest(
        'http://localhost/api/market-intelligence/overview?period=custom&startDate=2024-01-01&endDate=2024-01-15'
      )
      const response = await GET(request)

      expect(response.status).toBe(200)
      const data = await response.json()
      expect(data.periodo.inicio).toBe('2024-01-01')
      expect(data.periodo.fim).toBe('2024-01-15')
    })

    it('deve rejeitar data em formato invalido', async () => {
      const request = new NextRequest(
        'http://localhost/api/market-intelligence/overview?period=custom&startDate=01-01-2024&endDate=15-01-2024'
      )
      const response = await GET(request)

      expect(response.status).toBe(400)
    })
  })

  describe('Response Structure', () => {
    beforeEach(() => {
      mockSupabase.order.mockResolvedValue({
        data: [
          {
            data: '2024-01-01',
            grupos_ativos: 50,
            mensagens_total: 1000,
            mensagens_com_oferta: 100,
            vagas_extraidas: 80,
            vagas_importadas: 60,
            valor_medio_plantao: 150000,
            taxa_importacao: 0.75,
          },
        ],
        error: null,
      })
      mockSupabase.eq.mockResolvedValue({ count: 50, error: null })
      mockSupabase.lte.mockResolvedValue({ data: [], error: null })
    })

    it('deve retornar estrutura correta de periodo', async () => {
      const request = new NextRequest('http://localhost/api/market-intelligence/overview')
      const response = await GET(request)
      const data = await response.json()

      expect(data.periodo).toHaveProperty('inicio')
      expect(data.periodo).toHaveProperty('fim')
      expect(data.periodo).toHaveProperty('dias')
      expect(typeof data.periodo.dias).toBe('number')
    })

    it('deve retornar todos os KPIs', async () => {
      const request = new NextRequest('http://localhost/api/market-intelligence/overview')
      const response = await GET(request)
      const data = await response.json()

      expect(data.kpis).toHaveProperty('gruposAtivos')
      expect(data.kpis).toHaveProperty('vagasPorDia')
      expect(data.kpis).toHaveProperty('taxaConversao')
      expect(data.kpis).toHaveProperty('valorMedio')
    })

    it('deve retornar KPI com estrutura correta', async () => {
      const request = new NextRequest('http://localhost/api/market-intelligence/overview')
      const response = await GET(request)
      const data = await response.json()

      const kpi = data.kpis.gruposAtivos
      expect(kpi).toHaveProperty('valor')
      expect(kpi).toHaveProperty('valorFormatado')
      expect(kpi).toHaveProperty('variacao')
      expect(kpi).toHaveProperty('variacaoTipo')
      expect(kpi).toHaveProperty('tendencia')
      expect(Array.isArray(kpi.tendencia)).toBe(true)
    })

    it('deve retornar resumo com totais', async () => {
      const request = new NextRequest('http://localhost/api/market-intelligence/overview')
      const response = await GET(request)
      const data = await response.json()

      expect(data.resumo).toHaveProperty('totalMensagens')
      expect(data.resumo).toHaveProperty('totalOfertas')
      expect(data.resumo).toHaveProperty('totalVagasExtraidas')
      expect(data.resumo).toHaveProperty('totalVagasImportadas')
    })

    it('deve retornar updatedAt', async () => {
      const request = new NextRequest('http://localhost/api/market-intelligence/overview')
      const response = await GET(request)
      const data = await response.json()

      expect(data).toHaveProperty('updatedAt')
      expect(new Date(data.updatedAt).toString()).not.toBe('Invalid Date')
    })
  })

  describe('Calculos', () => {
    it('deve calcular variacao corretamente (positiva)', async () => {
      // Periodo atual: 100 vagas
      // Periodo anterior: 80 vagas
      // Variacao: +25%
      mockSupabase.order.mockResolvedValueOnce({
        data: [{ vagas_importadas: 100, vagas_extraidas: 100 }],
        error: null,
      })
      mockSupabase.order.mockResolvedValueOnce({
        data: [{ vagas_importadas: 80, vagas_extraidas: 80 }],
        error: null,
      })
      mockSupabase.eq.mockResolvedValue({ count: 50, error: null })
      mockSupabase.lte.mockResolvedValue({ data: [], error: null })

      const request = new NextRequest(
        'http://localhost/api/market-intelligence/overview?period=7d'
      )
      const response = await GET(request)
      const data = await response.json()

      // Verificar que variacao foi calculada
      expect(data.kpis.vagasPorDia.variacaoTipo).toBeDefined()
    })

    it('deve formatar valor monetario corretamente', async () => {
      mockSupabase.order.mockResolvedValue({
        data: [{ valor_medio_plantao: 150000 }], // R$ 1.500,00 em centavos
        error: null,
      })
      mockSupabase.eq.mockResolvedValue({ count: 50, error: null })
      mockSupabase.lte.mockResolvedValue({ data: [], error: null })

      const request = new NextRequest('http://localhost/api/market-intelligence/overview')
      const response = await GET(request)
      const data = await response.json()

      expect(data.kpis.valorMedio.valorFormatado).toMatch(/R\$/)
    })
  })

  describe('Tratamento de Erros', () => {
    it('deve retornar 500 quando banco falha', async () => {
      mockSupabase.order.mockResolvedValue({
        data: null,
        error: { message: 'Database error' },
      })

      const request = new NextRequest('http://localhost/api/market-intelligence/overview')
      const response = await GET(request)

      expect(response.status).toBe(500)
      const data = await response.json()
      expect(data.error).toBe('INTERNAL_ERROR')
    })
  })
})
```

---

## Definition of Done (DoD)

### Checklist Obrigatorio

- [ ] Arquivo criado em `app/api/market-intelligence/overview/route.ts`
- [ ] Validacao com Zod implementada
- [ ] Todos os query parameters funcionando
- [ ] Response segue exatamente o schema definido
- [ ] Tratamento de erros implementado
- [ ] Testes de integracao escritos
- [ ] Cobertura de testes >= 80%
- [ ] Endpoint responde em < 500ms
- [ ] Zero erros de TypeScript

### Comandos de Verificacao

```bash
# Rodar testes
npm run test -- __tests__/api/market-intelligence/overview.test.ts

# Verificar cobertura
npm run test -- __tests__/api/market-intelligence/overview.test.ts --coverage

# Testar endpoint manualmente
curl "http://localhost:3000/api/market-intelligence/overview?period=30d"

# Testar com periodo customizado
curl "http://localhost:3000/api/market-intelligence/overview?period=custom&startDate=2024-01-01&endDate=2024-01-31"
```

---

## Criterios de Aceitacao

| ID | Criterio | Verificacao |
|----|----------|-------------|
| AC1 | Endpoint existe | GET /api/market-intelligence/overview retorna 200 |
| AC2 | Valida parametros | period=invalid retorna 400 |
| AC3 | Retorna KPIs | Response contem kpis.gruposAtivos, vagasPorDia, etc |
| AC4 | Calcula variacao | KPIs tem variacao e variacaoTipo |
| AC5 | Retorna tendencia | KPIs tem array tendencia |
| AC6 | Formata valores | valorMedio.valorFormatado contem R$ |
| AC7 | Performance OK | Response time < 500ms |
| AC8 | Testes passam | npm run test passa |
| AC9 | Cobertura >= 80% | Coverage report >= 80% |

---

## Notas para o Desenvolvedor

1. **Supabase Client**: Usar `createClient()` de `@/lib/supabase/server` para server-side
2. **Datas**: Sempre trabalhar com UTC internamente, converter para display no frontend
3. **Performance**: Se queries ficarem lentas, priorizar uso das views materializadas
4. **Cache**: Sera adicionado Redis em epico futuro, por enquanto sem cache
5. **Erros**: Logar erros com contexto suficiente para debug
