# E46.10 - Componente GroupsRanking

## Resumo

Criar o componente React que exibe o ranking de grupos WhatsApp ordenados por qualidade/volume de vagas.

## Contexto

Este componente mostra uma tabela/lista dos grupos mais produtivos, baseado na view materializada `mv_grupos_ranking`, permitindo identificar rapidamente quais grupos geram mais vagas de qualidade.

## Escopo

### Incluido
- Componente `GroupsRanking`
- Tabela ordenavel por diferentes metricas
- Badge de score de qualidade
- Indicadores visuais de tendencia
- Paginacao
- Skeleton de loading
- Testes unitarios

### Excluido
- Filtros por regiao/tipo (sera adicionado depois)
- Export CSV

---

## Especificacao Tecnica

### Props

```typescript
interface GroupsRankingProps {
  data: GrupoRanking[] | null
  isLoading?: boolean
  className?: string
  limit?: number // default: 10
  onGroupClick?: (grupoId: string) => void
}

interface GrupoRanking {
  grupoId: string
  grupoNome: string
  grupoTipo: string
  grupoRegiao: string | null
  grupoAtivo: boolean
  mensagens30d: number
  ofertas30d: number
  vagasExtraidas30d: number
  vagasImportadas30d: number
  confiancaMedia30d: number | null
  valorMedio30d: number | null
  scoreQualidade: number
  ultimaMensagemEm: string | null
  ultimaVagaEm: string | null
}
```

### Visual

- Tabela com colunas: Posicao, Nome, Score, Vagas, Valor Medio, Ultima Atividade
- Badge colorido para score (verde > 70, amarelo 40-70, vermelho < 40)
- Icone de status (ativo/inativo)
- Ordenacao por clique no header

---

## Implementacao

### Arquivo: `dashboard/components/market-intelligence/groups-ranking.tsx`

```typescript
/**
 * GroupsRanking - Sprint 46
 *
 * Tabela de ranking de grupos por qualidade e volume de vagas.
 */

'use client'

import { useState, useMemo } from 'react'
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from '@/components/ui/table'
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card'
import { Badge } from '@/components/ui/badge'
import { Button } from '@/components/ui/button'
import { Skeleton } from '@/components/ui/skeleton'
import { cn } from '@/lib/utils'
import {
  ArrowUpDown,
  ArrowUp,
  ArrowDown,
  Circle,
  CheckCircle2,
  Clock,
  ChevronLeft,
  ChevronRight,
} from 'lucide-react'
import type { GrupoRanking } from '@/types/market-intelligence'

// =============================================================================
// TYPES
// =============================================================================

export interface GroupsRankingProps {
  data: GrupoRanking[] | null
  isLoading?: boolean
  className?: string
  limit?: number
  onGroupClick?: (grupoId: string) => void
  title?: string
}

type SortKey = 'scoreQualidade' | 'vagasImportadas30d' | 'valorMedio30d' | 'ultimaVagaEm'
type SortOrder = 'asc' | 'desc'

// =============================================================================
// CONSTANTS
// =============================================================================

const ITEMS_PER_PAGE = 10

// =============================================================================
// HELPERS
// =============================================================================

function formatNumber(value: number | null): string {
  if (value === null) return '-'
  return value.toLocaleString('pt-BR')
}

function formatCurrency(centavos: number | null): string {
  if (centavos === null) return '-'
  return new Intl.NumberFormat('pt-BR', {
    style: 'currency',
    currency: 'BRL',
    minimumFractionDigits: 0,
  }).format(centavos / 100)
}

function formatDate(dateStr: string | null): string {
  if (!dateStr) return 'Nunca'
  const date = new Date(dateStr)
  const now = new Date()
  const diffMs = now.getTime() - date.getTime()
  const diffDays = Math.floor(diffMs / (1000 * 60 * 60 * 24))

  if (diffDays === 0) return 'Hoje'
  if (diffDays === 1) return 'Ontem'
  if (diffDays < 7) return `${diffDays} dias atras`
  if (diffDays < 30) return `${Math.floor(diffDays / 7)} sem atras`
  return date.toLocaleDateString('pt-BR', { day: '2-digit', month: '2-digit' })
}

function getScoreBadgeVariant(score: number): 'default' | 'secondary' | 'destructive' | 'outline' {
  if (score >= 70) return 'default' // verde
  if (score >= 40) return 'secondary' // amarelo
  return 'destructive' // vermelho
}

function getScoreColor(score: number): string {
  if (score >= 70) return 'bg-green-500'
  if (score >= 40) return 'bg-yellow-500'
  return 'bg-red-500'
}

// =============================================================================
// SUBCOMPONENTS
// =============================================================================

function GroupsRankingSkeleton() {
  return (
    <Card>
      <CardHeader>
        <Skeleton className="h-6 w-48" />
      </CardHeader>
      <CardContent>
        <div className="space-y-3">
          {Array.from({ length: 5 }).map((_, i) => (
            <Skeleton key={i} className="h-12 w-full" />
          ))}
        </div>
      </CardContent>
    </Card>
  )
}

interface SortButtonProps {
  label: string
  sortKey: SortKey
  currentSort: SortKey
  currentOrder: SortOrder
  onSort: (key: SortKey) => void
}

function SortButton({ label, sortKey, currentSort, currentOrder, onSort }: SortButtonProps) {
  const isActive = currentSort === sortKey

  return (
    <Button
      variant="ghost"
      size="sm"
      className="-ml-3 h-8"
      onClick={() => onSort(sortKey)}
    >
      {label}
      {isActive ? (
        currentOrder === 'desc' ? (
          <ArrowDown className="ml-1 h-4 w-4" />
        ) : (
          <ArrowUp className="ml-1 h-4 w-4" />
        )
      ) : (
        <ArrowUpDown className="ml-1 h-4 w-4 opacity-50" />
      )}
    </Button>
  )
}

interface ScoreBadgeProps {
  score: number
}

function ScoreBadge({ score }: ScoreBadgeProps) {
  return (
    <Badge variant={getScoreBadgeVariant(score)} className="font-mono">
      {score}
    </Badge>
  )
}

interface StatusIconProps {
  ativo: boolean
}

function StatusIcon({ ativo }: StatusIconProps) {
  if (ativo) {
    return <CheckCircle2 className="h-4 w-4 text-green-500" aria-label="Grupo ativo" />
  }
  return <Circle className="h-4 w-4 text-muted-foreground" aria-label="Grupo inativo" />
}

// =============================================================================
// MAIN COMPONENT
// =============================================================================

export function GroupsRanking({
  data,
  isLoading = false,
  className,
  limit,
  onGroupClick,
  title = 'Ranking de Grupos',
}: GroupsRankingProps) {
  // Estado de ordenacao
  const [sortKey, setSortKey] = useState<SortKey>('scoreQualidade')
  const [sortOrder, setSortOrder] = useState<SortOrder>('desc')
  const [currentPage, setCurrentPage] = useState(1)

  // Handler de ordenacao
  const handleSort = (key: SortKey) => {
    if (sortKey === key) {
      setSortOrder((prev) => (prev === 'desc' ? 'asc' : 'desc'))
    } else {
      setSortKey(key)
      setSortOrder('desc')
    }
    setCurrentPage(1) // Reset para primeira pagina
  }

  // Ordenar e paginar dados
  const sortedData = useMemo(() => {
    if (!data) return []

    const sorted = [...data].sort((a, b) => {
      let aVal: number | string | null
      let bVal: number | string | null

      switch (sortKey) {
        case 'scoreQualidade':
          aVal = a.scoreQualidade
          bVal = b.scoreQualidade
          break
        case 'vagasImportadas30d':
          aVal = a.vagasImportadas30d
          bVal = b.vagasImportadas30d
          break
        case 'valorMedio30d':
          aVal = a.valorMedio30d ?? 0
          bVal = b.valorMedio30d ?? 0
          break
        case 'ultimaVagaEm':
          aVal = a.ultimaVagaEm ?? ''
          bVal = b.ultimaVagaEm ?? ''
          break
        default:
          return 0
      }

      if (typeof aVal === 'string' && typeof bVal === 'string') {
        return sortOrder === 'desc'
          ? bVal.localeCompare(aVal)
          : aVal.localeCompare(bVal)
      }

      return sortOrder === 'desc'
        ? (bVal as number) - (aVal as number)
        : (aVal as number) - (bVal as number)
    })

    // Aplicar limite se especificado
    if (limit) {
      return sorted.slice(0, limit)
    }

    return sorted
  }, [data, sortKey, sortOrder, limit])

  // Paginacao
  const paginatedData = useMemo(() => {
    if (limit) return sortedData // Se tem limite, nao pagina

    const start = (currentPage - 1) * ITEMS_PER_PAGE
    const end = start + ITEMS_PER_PAGE
    return sortedData.slice(start, end)
  }, [sortedData, currentPage, limit])

  const totalPages = limit ? 1 : Math.ceil(sortedData.length / ITEMS_PER_PAGE)

  // Loading state
  if (isLoading) {
    return <GroupsRankingSkeleton />
  }

  // Empty state
  if (!data || data.length === 0) {
    return (
      <Card className={className}>
        <CardHeader>
          <CardTitle>{title}</CardTitle>
        </CardHeader>
        <CardContent>
          <div className="flex h-[200px] items-center justify-center text-muted-foreground">
            Nenhum grupo encontrado
          </div>
        </CardContent>
      </Card>
    )
  }

  return (
    <Card className={className}>
      <CardHeader>
        <CardTitle>{title}</CardTitle>
      </CardHeader>
      <CardContent>
        <div className="rounded-md border">
          <Table>
            <TableHeader>
              <TableRow>
                <TableHead className="w-12">#</TableHead>
                <TableHead>Grupo</TableHead>
                <TableHead className="w-24">
                  <SortButton
                    label="Score"
                    sortKey="scoreQualidade"
                    currentSort={sortKey}
                    currentOrder={sortOrder}
                    onSort={handleSort}
                  />
                </TableHead>
                <TableHead className="w-24">
                  <SortButton
                    label="Vagas"
                    sortKey="vagasImportadas30d"
                    currentSort={sortKey}
                    currentOrder={sortOrder}
                    onSort={handleSort}
                  />
                </TableHead>
                <TableHead className="w-28">
                  <SortButton
                    label="Valor Med."
                    sortKey="valorMedio30d"
                    currentSort={sortKey}
                    currentOrder={sortOrder}
                    onSort={handleSort}
                  />
                </TableHead>
                <TableHead className="w-28">
                  <SortButton
                    label="Ult. Vaga"
                    sortKey="ultimaVagaEm"
                    currentSort={sortKey}
                    currentOrder={sortOrder}
                    onSort={handleSort}
                  />
                </TableHead>
              </TableRow>
            </TableHeader>
            <TableBody>
              {paginatedData.map((grupo, index) => {
                const position = limit
                  ? index + 1
                  : (currentPage - 1) * ITEMS_PER_PAGE + index + 1

                return (
                  <TableRow
                    key={grupo.grupoId}
                    className={cn(
                      onGroupClick && 'cursor-pointer hover:bg-muted/50'
                    )}
                    onClick={() => onGroupClick?.(grupo.grupoId)}
                  >
                    <TableCell className="font-medium text-muted-foreground">
                      {position}
                    </TableCell>
                    <TableCell>
                      <div className="flex items-center gap-2">
                        <StatusIcon ativo={grupo.grupoAtivo} />
                        <div>
                          <div className="font-medium line-clamp-1">{grupo.grupoNome}</div>
                          {grupo.grupoRegiao && (
                            <div className="text-xs text-muted-foreground">
                              {grupo.grupoRegiao}
                            </div>
                          )}
                        </div>
                      </div>
                    </TableCell>
                    <TableCell>
                      <ScoreBadge score={grupo.scoreQualidade} />
                    </TableCell>
                    <TableCell className="font-medium">
                      {formatNumber(grupo.vagasImportadas30d)}
                    </TableCell>
                    <TableCell>{formatCurrency(grupo.valorMedio30d)}</TableCell>
                    <TableCell>
                      <div className="flex items-center gap-1 text-sm text-muted-foreground">
                        <Clock className="h-3 w-3" />
                        {formatDate(grupo.ultimaVagaEm)}
                      </div>
                    </TableCell>
                  </TableRow>
                )
              })}
            </TableBody>
          </Table>
        </div>

        {/* Paginacao */}
        {!limit && totalPages > 1 && (
          <div className="mt-4 flex items-center justify-between">
            <div className="text-sm text-muted-foreground">
              Mostrando {(currentPage - 1) * ITEMS_PER_PAGE + 1} -{' '}
              {Math.min(currentPage * ITEMS_PER_PAGE, sortedData.length)} de{' '}
              {sortedData.length}
            </div>
            <div className="flex gap-2">
              <Button
                variant="outline"
                size="sm"
                onClick={() => setCurrentPage((p) => Math.max(1, p - 1))}
                disabled={currentPage === 1}
              >
                <ChevronLeft className="h-4 w-4" />
                Anterior
              </Button>
              <Button
                variant="outline"
                size="sm"
                onClick={() => setCurrentPage((p) => Math.min(totalPages, p + 1))}
                disabled={currentPage === totalPages}
              >
                Proximo
                <ChevronRight className="h-4 w-4" />
              </Button>
            </div>
          </div>
        )}
      </CardContent>
    </Card>
  )
}

export default GroupsRanking
```

---

## Testes

### Arquivo: `dashboard/__tests__/components/market-intelligence/groups-ranking.test.tsx`

```typescript
/**
 * Testes Unitarios - GroupsRanking
 */

import { render, screen, fireEvent, within } from '@testing-library/react'
import userEvent from '@testing-library/user-event'
import { GroupsRanking } from '@/components/market-intelligence/groups-ranking'
import type { GrupoRanking } from '@/types/market-intelligence'

// =============================================================================
// TEST DATA
// =============================================================================

const mockData: GrupoRanking[] = [
  {
    grupoId: '1',
    grupoNome: 'Grupo Cardiologia SP',
    grupoTipo: 'especialidade',
    grupoRegiao: 'Sao Paulo',
    grupoAtivo: true,
    mensagens30d: 500,
    ofertas30d: 150,
    vagasExtraidas30d: 100,
    vagasImportadas30d: 80,
    confiancaMedia30d: 0.85,
    valorMedio30d: 180000, // R$ 1.800
    scoreQualidade: 85,
    ultimaMensagemEm: '2024-01-31T10:00:00Z',
    ultimaVagaEm: '2024-01-31T08:00:00Z',
  },
  {
    grupoId: '2',
    grupoNome: 'Plantoes Urgencia RJ',
    grupoTipo: 'urgencia',
    grupoRegiao: 'Rio de Janeiro',
    grupoAtivo: true,
    mensagens30d: 300,
    ofertas30d: 90,
    vagasExtraidas30d: 60,
    vagasImportadas30d: 45,
    confiancaMedia30d: 0.78,
    valorMedio30d: 150000,
    scoreQualidade: 65,
    ultimaMensagemEm: '2024-01-30T15:00:00Z',
    ultimaVagaEm: '2024-01-30T12:00:00Z',
  },
  {
    grupoId: '3',
    grupoNome: 'Grupo Inativo',
    grupoTipo: 'geral',
    grupoRegiao: null,
    grupoAtivo: false,
    mensagens30d: 10,
    ofertas30d: 2,
    vagasExtraidas30d: 1,
    vagasImportadas30d: 0,
    confiancaMedia30d: null,
    valorMedio30d: null,
    scoreQualidade: 15,
    ultimaMensagemEm: '2024-01-01T10:00:00Z',
    ultimaVagaEm: null,
  },
]

// =============================================================================
// TESTS
// =============================================================================

describe('GroupsRanking', () => {
  describe('Renderizacao', () => {
    it('deve renderizar o componente com dados', () => {
      render(<GroupsRanking data={mockData} />)

      expect(screen.getByText('Ranking de Grupos')).toBeInTheDocument()
    })

    it('deve renderizar titulo customizado', () => {
      render(<GroupsRanking data={mockData} title="Top Grupos" />)

      expect(screen.getByText('Top Grupos')).toBeInTheDocument()
    })

    it('deve renderizar skeleton quando isLoading=true', () => {
      render(<GroupsRanking data={null} isLoading />)

      expect(screen.queryByText('Ranking de Grupos')).not.toBeInTheDocument()
    })

    it('deve renderizar empty state quando data=null', () => {
      render(<GroupsRanking data={null} />)

      expect(screen.getByText(/nenhum grupo encontrado/i)).toBeInTheDocument()
    })

    it('deve renderizar empty state quando data=[]', () => {
      render(<GroupsRanking data={[]} />)

      expect(screen.getByText(/nenhum grupo encontrado/i)).toBeInTheDocument()
    })

    it('deve aplicar className customizado', () => {
      const { container } = render(
        <GroupsRanking data={mockData} className="custom-class" />
      )

      expect(container.firstChild).toHaveClass('custom-class')
    })
  })

  describe('Tabela', () => {
    it('deve renderizar todas as colunas', () => {
      render(<GroupsRanking data={mockData} />)

      expect(screen.getByText('#')).toBeInTheDocument()
      expect(screen.getByText('Grupo')).toBeInTheDocument()
      expect(screen.getByRole('button', { name: /score/i })).toBeInTheDocument()
      expect(screen.getByRole('button', { name: /vagas/i })).toBeInTheDocument()
      expect(screen.getByRole('button', { name: /valor med/i })).toBeInTheDocument()
      expect(screen.getByRole('button', { name: /ult\. vaga/i })).toBeInTheDocument()
    })

    it('deve renderizar todas as linhas', () => {
      render(<GroupsRanking data={mockData} />)

      expect(screen.getByText('Grupo Cardiologia SP')).toBeInTheDocument()
      expect(screen.getByText('Plantoes Urgencia RJ')).toBeInTheDocument()
      expect(screen.getByText('Grupo Inativo')).toBeInTheDocument()
    })

    it('deve exibir regiao quando disponivel', () => {
      render(<GroupsRanking data={mockData} />)

      expect(screen.getByText('Sao Paulo')).toBeInTheDocument()
      expect(screen.getByText('Rio de Janeiro')).toBeInTheDocument()
    })

    it('deve exibir posicao correta', () => {
      render(<GroupsRanking data={mockData} />)

      const rows = screen.getAllByRole('row')
      // Header + 3 data rows
      expect(rows).toHaveLength(4)
    })
  })

  describe('Score Badge', () => {
    it('deve renderizar badge para cada grupo', () => {
      render(<GroupsRanking data={mockData} />)

      expect(screen.getByText('85')).toBeInTheDocument() // Score alto
      expect(screen.getByText('65')).toBeInTheDocument() // Score medio
      expect(screen.getByText('15')).toBeInTheDocument() // Score baixo
    })
  })

  describe('Status Icon', () => {
    it('deve mostrar icone de ativo para grupos ativos', () => {
      render(<GroupsRanking data={mockData} />)

      const activeIcons = screen.getAllByLabelText('Grupo ativo')
      expect(activeIcons).toHaveLength(2) // 2 grupos ativos
    })

    it('deve mostrar icone diferente para grupos inativos', () => {
      render(<GroupsRanking data={mockData} />)

      const inactiveIcons = screen.getAllByLabelText('Grupo inativo')
      expect(inactiveIcons).toHaveLength(1) // 1 grupo inativo
    })
  })

  describe('Ordenacao', () => {
    it('deve ordenar por score por default (desc)', () => {
      render(<GroupsRanking data={mockData} />)

      const rows = screen.getAllByRole('row').slice(1) // Skip header
      expect(within(rows[0]).getByText('Grupo Cardiologia SP')).toBeInTheDocument()
      expect(within(rows[1]).getByText('Plantoes Urgencia RJ')).toBeInTheDocument()
      expect(within(rows[2]).getByText('Grupo Inativo')).toBeInTheDocument()
    })

    it('deve inverter ordem ao clicar no mesmo header', async () => {
      const user = userEvent.setup()
      render(<GroupsRanking data={mockData} />)

      const scoreButton = screen.getByRole('button', { name: /score/i })
      await user.click(scoreButton) // Click inverte para asc

      const rows = screen.getAllByRole('row').slice(1)
      expect(within(rows[0]).getByText('Grupo Inativo')).toBeInTheDocument() // Score mais baixo primeiro
    })

    it('deve ordenar por vagas ao clicar no header', async () => {
      const user = userEvent.setup()
      render(<GroupsRanking data={mockData} />)

      const vagasButton = screen.getByRole('button', { name: /vagas/i })
      await user.click(vagasButton)

      // Agora ordenado por vagas (desc)
      const rows = screen.getAllByRole('row').slice(1)
      expect(within(rows[0]).getByText('Grupo Cardiologia SP')).toBeInTheDocument() // 80 vagas
    })

    it('deve ordenar por valor medio', async () => {
      const user = userEvent.setup()
      render(<GroupsRanking data={mockData} />)

      const valorButton = screen.getByRole('button', { name: /valor med/i })
      await user.click(valorButton)

      // Ordenado por valor (desc)
      const rows = screen.getAllByRole('row').slice(1)
      expect(within(rows[0]).getByText('Grupo Cardiologia SP')).toBeInTheDocument() // R$ 1.800
    })
  })

  describe('Limite', () => {
    it('deve respeitar prop limit', () => {
      render(<GroupsRanking data={mockData} limit={2} />)

      const rows = screen.getAllByRole('row').slice(1)
      expect(rows).toHaveLength(2)
    })

    it('nao deve mostrar paginacao quando limit esta definido', () => {
      render(<GroupsRanking data={mockData} limit={2} />)

      expect(screen.queryByText('Anterior')).not.toBeInTheDocument()
      expect(screen.queryByText('Proximo')).not.toBeInTheDocument()
    })
  })

  describe('Click Handler', () => {
    it('deve chamar onGroupClick quando linha e clicada', async () => {
      const user = userEvent.setup()
      const handleClick = jest.fn()
      render(<GroupsRanking data={mockData} onGroupClick={handleClick} />)

      const row = screen.getByText('Grupo Cardiologia SP').closest('tr')
      await user.click(row!)

      expect(handleClick).toHaveBeenCalledWith('1')
    })

    it('nao deve ter cursor pointer sem onGroupClick', () => {
      render(<GroupsRanking data={mockData} />)

      const row = screen.getByText('Grupo Cardiologia SP').closest('tr')
      expect(row).not.toHaveClass('cursor-pointer')
    })
  })

  describe('Formatacao', () => {
    it('deve formatar valores monetarios corretamente', () => {
      render(<GroupsRanking data={mockData} />)

      expect(screen.getByText('R$ 1.800')).toBeInTheDocument()
      expect(screen.getByText('R$ 1.500')).toBeInTheDocument()
    })

    it('deve exibir "-" para valores null', () => {
      render(<GroupsRanking data={mockData} />)

      // Grupo inativo tem valorMedio30d = null
      const rows = screen.getAllByRole('row')
      const lastRow = rows[rows.length - 1]
      expect(within(lastRow).getByText('-')).toBeInTheDocument()
    })

    it('deve formatar data relativa corretamente', () => {
      render(<GroupsRanking data={mockData} />)

      // Grupo inativo tem ultimaVagaEm = null
      expect(screen.getByText('Nunca')).toBeInTheDocument()
    })
  })

  describe('Acessibilidade', () => {
    it('deve ter aria-labels nos icones de status', () => {
      render(<GroupsRanking data={mockData} />)

      expect(screen.getAllByLabelText(/grupo ativo|grupo inativo/i).length).toBeGreaterThan(0)
    })

    it('deve ter tabela com role correto', () => {
      render(<GroupsRanking data={mockData} />)

      expect(screen.getByRole('table')).toBeInTheDocument()
    })
  })
})
```

---

## Definition of Done (DoD)

### Checklist Obrigatorio

- [ ] Arquivo criado em `components/market-intelligence/groups-ranking.tsx`
- [ ] Tabela com 6 colunas renderizada
- [ ] Ordenacao por 4 colunas funcionando
- [ ] Badge de score com cores corretas
- [ ] Icone de status (ativo/inativo)
- [ ] Paginacao funcionando
- [ ] Prop limit respeitada
- [ ] onGroupClick callback funcionando
- [ ] Skeleton de loading
- [ ] Empty state
- [ ] Testes unitarios escritos
- [ ] Cobertura de testes >= 80%
- [ ] Zero erros de TypeScript

### Comandos de Verificacao

```bash
# Rodar testes
npm run test -- __tests__/components/market-intelligence/groups-ranking.test.tsx

# Verificar cobertura
npm run test -- __tests__/components/market-intelligence/groups-ranking.test.tsx --coverage

# Type check
npm run type-check
```

---

## Criterios de Aceitacao

| ID | Criterio | Verificacao |
|----|----------|-------------|
| AC1 | Componente existe | import funciona |
| AC2 | Tabela renderiza | 6 colunas visiveis |
| AC3 | Ordenacao funciona | Click no header ordena |
| AC4 | Score badge | Cores corretas por faixa |
| AC5 | Status icon | Diferencia ativo/inativo |
| AC6 | Paginacao | Navega entre paginas |
| AC7 | Limit prop | Respeita limite |
| AC8 | Click handler | Callback chamado |
| AC9 | Testes passam | npm run test passa |
| AC10 | Cobertura >= 80% | Coverage report >= 80% |

---

## Notas para o Desenvolvedor

1. **Ordenacao**: Manter estado local, nao refazer fetch
2. **Paginacao**: 10 items por pagina, desabilitar quando limit definido
3. **Score Badge**: Verde >= 70, Amarelo 40-70, Vermelho < 40
4. **Valores Null**: Exibir "-" ou "Nunca" conforme contexto
5. **Performance**: Usar useMemo para dados ordenados/paginados
