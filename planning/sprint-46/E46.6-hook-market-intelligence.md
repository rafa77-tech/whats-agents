# E46.6 - Hook useMarketIntelligence

## Resumo

Criar o hook React que encapsula a logica de busca e gerenciamento de estado dos dados de Market Intelligence.

## Contexto

Este hook sera o ponto central de acesso aos dados de Market Intelligence no frontend. Ele gerencia chamadas as 3 APIs (overview, volume, pipeline), estado de loading/erro, e refresh dos dados.

## Escopo

### Incluido
- Hook `useMarketIntelligence`
- Gerenciamento de estado (loading, error, data)
- Chamadas paralelas as APIs
- Funcao de refresh
- Selecao de periodo
- Memoizacao para performance

### Excluido
- Cache persistente (localStorage)
- Polling automatico

---

## Especificacao Tecnica

### Interface do Hook

```typescript
interface UseMarketIntelligenceOptions {
  period?: AnalyticsPeriod // default: '30d'
  startDate?: string
  endDate?: string
  autoFetch?: boolean // default: true
}

interface UseMarketIntelligenceReturn {
  // Dados
  overview: MarketOverviewResponse | null
  volume: VolumeResponse | null
  pipeline: PipelineResponse | null

  // Estado
  isLoading: boolean
  isRefreshing: boolean
  error: Error | null

  // Acoes
  refresh: () => Promise<void>
  setPeriod: (period: AnalyticsPeriod) => void
  setCustomPeriod: (startDate: string, endDate: string) => void

  // Metadata
  lastUpdated: Date | null
  period: AnalyticsPeriod
}
```

---

## Implementacao

### Arquivo: `dashboard/hooks/use-market-intelligence.ts`

```typescript
/**
 * Hook useMarketIntelligence - Sprint 46
 *
 * Gerencia estado e busca de dados de Market Intelligence.
 */

'use client'

import { useState, useEffect, useCallback, useMemo } from 'react'
import type {
  AnalyticsPeriod,
  MarketOverviewResponse,
  VolumeResponse,
  PipelineResponse,
} from '@/types/market-intelligence'

// =============================================================================
// TYPES
// =============================================================================

export interface UseMarketIntelligenceOptions {
  period?: AnalyticsPeriod
  startDate?: string
  endDate?: string
  autoFetch?: boolean
}

export interface UseMarketIntelligenceReturn {
  // Dados
  overview: MarketOverviewResponse | null
  volume: VolumeResponse | null
  pipeline: PipelineResponse | null

  // Estado
  isLoading: boolean
  isRefreshing: boolean
  error: Error | null

  // Acoes
  refresh: () => Promise<void>
  setPeriod: (period: AnalyticsPeriod) => void
  setCustomPeriod: (startDate: string, endDate: string) => void

  // Metadata
  lastUpdated: Date | null
  period: AnalyticsPeriod
  customDates: { startDate: string; endDate: string } | null
}

// =============================================================================
// API FUNCTIONS
// =============================================================================

async function fetchOverview(
  period: AnalyticsPeriod,
  startDate?: string,
  endDate?: string
): Promise<MarketOverviewResponse> {
  const params = new URLSearchParams({ period })
  if (period === 'custom' && startDate && endDate) {
    params.set('startDate', startDate)
    params.set('endDate', endDate)
  }

  const response = await fetch(`/api/market-intelligence/overview?${params}`)
  if (!response.ok) {
    const error = await response.json()
    throw new Error(error.message || 'Erro ao buscar overview')
  }
  return response.json()
}

async function fetchVolume(
  period: AnalyticsPeriod,
  startDate?: string,
  endDate?: string
): Promise<VolumeResponse> {
  const params = new URLSearchParams({ period })
  if (period === 'custom' && startDate && endDate) {
    params.set('startDate', startDate)
    params.set('endDate', endDate)
  }

  const response = await fetch(`/api/market-intelligence/volume?${params}`)
  if (!response.ok) {
    const error = await response.json()
    throw new Error(error.message || 'Erro ao buscar volume')
  }
  return response.json()
}

async function fetchPipeline(
  period: AnalyticsPeriod,
  startDate?: string,
  endDate?: string
): Promise<PipelineResponse> {
  const params = new URLSearchParams({ period })
  if (period === 'custom' && startDate && endDate) {
    params.set('startDate', startDate)
    params.set('endDate', endDate)
  }

  const response = await fetch(`/api/market-intelligence/pipeline?${params}`)
  if (!response.ok) {
    const error = await response.json()
    throw new Error(error.message || 'Erro ao buscar pipeline')
  }
  return response.json()
}

// =============================================================================
// HOOK
// =============================================================================

export function useMarketIntelligence(
  options: UseMarketIntelligenceOptions = {}
): UseMarketIntelligenceReturn {
  const { period: initialPeriod = '30d', startDate, endDate, autoFetch = true } = options

  // Estado
  const [period, setPeriodState] = useState<AnalyticsPeriod>(initialPeriod)
  const [customDates, setCustomDates] = useState<{ startDate: string; endDate: string } | null>(
    startDate && endDate ? { startDate, endDate } : null
  )
  const [overview, setOverview] = useState<MarketOverviewResponse | null>(null)
  const [volume, setVolume] = useState<VolumeResponse | null>(null)
  const [pipeline, setPipeline] = useState<PipelineResponse | null>(null)
  const [isLoading, setIsLoading] = useState(false)
  const [isRefreshing, setIsRefreshing] = useState(false)
  const [error, setError] = useState<Error | null>(null)
  const [lastUpdated, setLastUpdated] = useState<Date | null>(null)

  // Funcao de busca principal
  const fetchData = useCallback(
    async (isRefresh = false) => {
      if (isRefresh) {
        setIsRefreshing(true)
      } else {
        setIsLoading(true)
      }
      setError(null)

      try {
        const currentStartDate = period === 'custom' ? customDates?.startDate : undefined
        const currentEndDate = period === 'custom' ? customDates?.endDate : undefined

        // Buscar todos os dados em paralelo
        const [overviewData, volumeData, pipelineData] = await Promise.all([
          fetchOverview(period, currentStartDate, currentEndDate),
          fetchVolume(period, currentStartDate, currentEndDate),
          fetchPipeline(period, currentStartDate, currentEndDate),
        ])

        setOverview(overviewData)
        setVolume(volumeData)
        setPipeline(pipelineData)
        setLastUpdated(new Date())
      } catch (err) {
        const errorMessage = err instanceof Error ? err : new Error('Erro desconhecido')
        setError(errorMessage)
        console.error('[useMarketIntelligence] Erro:', err)
      } finally {
        setIsLoading(false)
        setIsRefreshing(false)
      }
    },
    [period, customDates]
  )

  // Funcao de refresh exposta
  const refresh = useCallback(async () => {
    await fetchData(true)
  }, [fetchData])

  // Funcao para mudar periodo
  const setPeriod = useCallback((newPeriod: AnalyticsPeriod) => {
    if (newPeriod !== 'custom') {
      setCustomDates(null)
    }
    setPeriodState(newPeriod)
  }, [])

  // Funcao para definir periodo customizado
  const setCustomPeriod = useCallback((newStartDate: string, newEndDate: string) => {
    setCustomDates({ startDate: newStartDate, endDate: newEndDate })
    setPeriodState('custom')
  }, [])

  // Effect para buscar dados iniciais e quando periodo muda
  useEffect(() => {
    if (autoFetch) {
      fetchData()
    }
  }, [fetchData, autoFetch])

  // Memoizar retorno para evitar re-renders desnecessarios
  const returnValue = useMemo(
    (): UseMarketIntelligenceReturn => ({
      overview,
      volume,
      pipeline,
      isLoading,
      isRefreshing,
      error,
      refresh,
      setPeriod,
      setCustomPeriod,
      lastUpdated,
      period,
      customDates,
    }),
    [
      overview,
      volume,
      pipeline,
      isLoading,
      isRefreshing,
      error,
      refresh,
      setPeriod,
      setCustomPeriod,
      lastUpdated,
      period,
      customDates,
    ]
  )

  return returnValue
}

export default useMarketIntelligence
```

---

## Testes

### Arquivo: `dashboard/__tests__/hooks/use-market-intelligence.test.ts`

```typescript
/**
 * Testes Unitarios - Hook useMarketIntelligence
 */

import { renderHook, waitFor, act } from '@testing-library/react'
import { useMarketIntelligence } from '@/hooks/use-market-intelligence'
import type { MarketOverviewResponse, VolumeResponse, PipelineResponse } from '@/types/market-intelligence'

// =============================================================================
// MOCKS
// =============================================================================

const mockOverviewResponse: MarketOverviewResponse = {
  periodo: { inicio: '2024-01-01', fim: '2024-01-31', dias: 31 },
  kpis: {
    gruposAtivos: { valor: 50, valorFormatado: '50', variacao: 10, variacaoTipo: 'up', tendencia: [45, 50] },
    vagasPorDia: { valor: 8.5, valorFormatado: '8.5/dia', variacao: 5, variacaoTipo: 'up', tendencia: [8, 8.5] },
    taxaConversao: { valor: 65, valorFormatado: '65%', variacao: -2, variacaoTipo: 'down', tendencia: [67, 65] },
    valorMedio: { valor: 150000, valorFormatado: 'R$ 1.500', variacao: null, variacaoTipo: null, tendencia: [1500] },
  },
  resumo: { totalMensagens: 5000, totalOfertas: 500, totalVagasExtraidas: 400, totalVagasImportadas: 260 },
  updatedAt: '2024-01-31T12:00:00Z',
}

const mockVolumeResponse: VolumeResponse = {
  periodo: { inicio: '2024-01-01', fim: '2024-01-31', dias: 31 },
  dados: [
    { data: '2024-01-01', mensagens: 150, ofertas: 45, vagasExtraidas: 30, vagasImportadas: 22 },
    { data: '2024-01-02', mensagens: 180, ofertas: 52, vagasExtraidas: 38, vagasImportadas: 28 },
  ],
  totais: { mensagens: 330, ofertas: 97, vagasExtraidas: 68, vagasImportadas: 50 },
  medias: { mensagensPorDia: 165, ofertasPorDia: 48.5, vagasExtraidasPorDia: 34, vagasImportadasPorDia: 25 },
  updatedAt: '2024-01-31T12:00:00Z',
}

const mockPipelineResponse: PipelineResponse = {
  periodo: { inicio: '2024-01-01', fim: '2024-01-31', dias: 31 },
  funil: {
    etapas: [
      { id: 'mensagens', nome: 'Mensagens', valor: 5000, percentual: 100 },
      { id: 'ofertas', nome: 'Ofertas', valor: 500, percentual: 10 },
      { id: 'importadas', nome: 'Importadas', valor: 260, percentual: 5.2 },
    ],
    conversoes: {
      mensagemParaOferta: 10,
      ofertaParaExtracao: 80,
      extracaoParaImportacao: 65,
      totalPipeline: 5.2,
    },
  },
  perdas: { duplicadas: 50, descartadas: 30, revisao: 20, semDadosMinimos: 40 },
  qualidade: { confiancaClassificacaoMedia: 0.87, confiancaExtracaoMedia: 0.82 },
  updatedAt: '2024-01-31T12:00:00Z',
}

// Setup global fetch mock
const mockFetch = jest.fn()
global.fetch = mockFetch

function setupSuccessfulMocks() {
  mockFetch.mockImplementation((url: string) => {
    if (url.includes('/overview')) {
      return Promise.resolve({
        ok: true,
        json: () => Promise.resolve(mockOverviewResponse),
      })
    }
    if (url.includes('/volume')) {
      return Promise.resolve({
        ok: true,
        json: () => Promise.resolve(mockVolumeResponse),
      })
    }
    if (url.includes('/pipeline')) {
      return Promise.resolve({
        ok: true,
        json: () => Promise.resolve(mockPipelineResponse),
      })
    }
    return Promise.reject(new Error('Unknown endpoint'))
  })
}

// =============================================================================
// TESTS
// =============================================================================

describe('useMarketIntelligence', () => {
  beforeEach(() => {
    jest.clearAllMocks()
  })

  describe('Inicializacao', () => {
    it('deve iniciar com estado de loading quando autoFetch=true', async () => {
      setupSuccessfulMocks()
      const { result } = renderHook(() => useMarketIntelligence())

      expect(result.current.isLoading).toBe(true)
      expect(result.current.overview).toBeNull()
      expect(result.current.volume).toBeNull()
      expect(result.current.pipeline).toBeNull()

      await waitFor(() => expect(result.current.isLoading).toBe(false))
    })

    it('nao deve fazer fetch quando autoFetch=false', async () => {
      setupSuccessfulMocks()
      const { result } = renderHook(() => useMarketIntelligence({ autoFetch: false }))

      expect(result.current.isLoading).toBe(false)
      expect(mockFetch).not.toHaveBeenCalled()
    })

    it('deve usar periodo default de 30d', async () => {
      setupSuccessfulMocks()
      const { result } = renderHook(() => useMarketIntelligence())

      await waitFor(() => expect(result.current.isLoading).toBe(false))

      expect(result.current.period).toBe('30d')
    })

    it('deve aceitar periodo inicial customizado', async () => {
      setupSuccessfulMocks()
      const { result } = renderHook(() => useMarketIntelligence({ period: '7d' }))

      await waitFor(() => expect(result.current.isLoading).toBe(false))

      expect(result.current.period).toBe('7d')
      expect(mockFetch).toHaveBeenCalledWith(expect.stringContaining('period=7d'))
    })
  })

  describe('Fetch de Dados', () => {
    it('deve buscar todos os 3 endpoints em paralelo', async () => {
      setupSuccessfulMocks()
      const { result } = renderHook(() => useMarketIntelligence())

      await waitFor(() => expect(result.current.isLoading).toBe(false))

      expect(mockFetch).toHaveBeenCalledTimes(3)
      expect(mockFetch).toHaveBeenCalledWith(expect.stringContaining('/overview'))
      expect(mockFetch).toHaveBeenCalledWith(expect.stringContaining('/volume'))
      expect(mockFetch).toHaveBeenCalledWith(expect.stringContaining('/pipeline'))
    })

    it('deve popular dados corretamente apos fetch', async () => {
      setupSuccessfulMocks()
      const { result } = renderHook(() => useMarketIntelligence())

      await waitFor(() => expect(result.current.isLoading).toBe(false))

      expect(result.current.overview).toEqual(mockOverviewResponse)
      expect(result.current.volume).toEqual(mockVolumeResponse)
      expect(result.current.pipeline).toEqual(mockPipelineResponse)
    })

    it('deve atualizar lastUpdated apos fetch', async () => {
      setupSuccessfulMocks()
      const { result } = renderHook(() => useMarketIntelligence())

      expect(result.current.lastUpdated).toBeNull()

      await waitFor(() => expect(result.current.isLoading).toBe(false))

      expect(result.current.lastUpdated).toBeInstanceOf(Date)
    })
  })

  describe('Tratamento de Erros', () => {
    it('deve setar error quando fetch falha', async () => {
      mockFetch.mockRejectedValue(new Error('Network error'))

      const { result } = renderHook(() => useMarketIntelligence())

      await waitFor(() => expect(result.current.isLoading).toBe(false))

      expect(result.current.error).not.toBeNull()
      expect(result.current.error?.message).toBe('Network error')
    })

    it('deve setar error quando API retorna erro', async () => {
      mockFetch.mockResolvedValue({
        ok: false,
        json: () => Promise.resolve({ message: 'API Error' }),
      })

      const { result } = renderHook(() => useMarketIntelligence())

      await waitFor(() => expect(result.current.isLoading).toBe(false))

      expect(result.current.error).not.toBeNull()
    })

    it('deve manter dados anteriores quando refresh falha', async () => {
      setupSuccessfulMocks()
      const { result } = renderHook(() => useMarketIntelligence())

      await waitFor(() => expect(result.current.isLoading).toBe(false))
      const overviewBeforeError = result.current.overview

      // Fazer proximo fetch falhar
      mockFetch.mockRejectedValue(new Error('Refresh error'))

      await act(async () => {
        await result.current.refresh()
      })

      // Dados devem ser mantidos (nao apagados)
      expect(result.current.overview).toEqual(overviewBeforeError)
    })
  })

  describe('Refresh', () => {
    it('deve setar isRefreshing=true durante refresh', async () => {
      setupSuccessfulMocks()
      const { result } = renderHook(() => useMarketIntelligence())

      await waitFor(() => expect(result.current.isLoading).toBe(false))

      let refreshingDuringCall = false

      mockFetch.mockImplementation(() => {
        refreshingDuringCall = result.current.isRefreshing
        return Promise.resolve({
          ok: true,
          json: () => Promise.resolve(mockOverviewResponse),
        })
      })

      await act(async () => {
        const refreshPromise = result.current.refresh()
        // Verificar que isRefreshing esta true
        expect(result.current.isRefreshing).toBe(true)
        await refreshPromise
      })

      expect(result.current.isRefreshing).toBe(false)
    })

    it('deve manter isLoading=false durante refresh', async () => {
      setupSuccessfulMocks()
      const { result } = renderHook(() => useMarketIntelligence())

      await waitFor(() => expect(result.current.isLoading).toBe(false))

      await act(async () => {
        result.current.refresh()
        expect(result.current.isLoading).toBe(false)
      })
    })

    it('deve chamar APIs novamente no refresh', async () => {
      setupSuccessfulMocks()
      const { result } = renderHook(() => useMarketIntelligence())

      await waitFor(() => expect(result.current.isLoading).toBe(false))
      expect(mockFetch).toHaveBeenCalledTimes(3)

      await act(async () => {
        await result.current.refresh()
      })

      expect(mockFetch).toHaveBeenCalledTimes(6) // 3 inicial + 3 refresh
    })
  })

  describe('Mudanca de Periodo', () => {
    it('deve refazer fetch quando periodo muda', async () => {
      setupSuccessfulMocks()
      const { result } = renderHook(() => useMarketIntelligence())

      await waitFor(() => expect(result.current.isLoading).toBe(false))
      mockFetch.mockClear()

      await act(async () => {
        result.current.setPeriod('7d')
      })

      await waitFor(() => expect(mockFetch).toHaveBeenCalled())

      expect(mockFetch).toHaveBeenCalledWith(expect.stringContaining('period=7d'))
    })

    it('deve atualizar estado do periodo', async () => {
      setupSuccessfulMocks()
      const { result } = renderHook(() => useMarketIntelligence())

      await waitFor(() => expect(result.current.isLoading).toBe(false))

      expect(result.current.period).toBe('30d')

      await act(async () => {
        result.current.setPeriod('90d')
      })

      expect(result.current.period).toBe('90d')
    })

    it('deve limpar customDates quando muda para periodo nao-custom', async () => {
      setupSuccessfulMocks()
      const { result } = renderHook(() =>
        useMarketIntelligence({
          period: 'custom',
          startDate: '2024-01-01',
          endDate: '2024-01-15',
        })
      )

      await waitFor(() => expect(result.current.isLoading).toBe(false))

      expect(result.current.customDates).not.toBeNull()

      await act(async () => {
        result.current.setPeriod('30d')
      })

      expect(result.current.customDates).toBeNull()
    })
  })

  describe('Periodo Customizado', () => {
    it('deve setar customDates e period=custom', async () => {
      setupSuccessfulMocks()
      const { result } = renderHook(() => useMarketIntelligence())

      await waitFor(() => expect(result.current.isLoading).toBe(false))

      await act(async () => {
        result.current.setCustomPeriod('2024-01-01', '2024-01-15')
      })

      expect(result.current.period).toBe('custom')
      expect(result.current.customDates).toEqual({
        startDate: '2024-01-01',
        endDate: '2024-01-15',
      })
    })

    it('deve passar datas para APIs quando period=custom', async () => {
      setupSuccessfulMocks()
      const { result } = renderHook(() => useMarketIntelligence())

      await waitFor(() => expect(result.current.isLoading).toBe(false))
      mockFetch.mockClear()

      await act(async () => {
        result.current.setCustomPeriod('2024-01-01', '2024-01-15')
      })

      await waitFor(() => expect(mockFetch).toHaveBeenCalled())

      expect(mockFetch).toHaveBeenCalledWith(expect.stringContaining('startDate=2024-01-01'))
      expect(mockFetch).toHaveBeenCalledWith(expect.stringContaining('endDate=2024-01-15'))
    })
  })

  describe('Performance', () => {
    it('nao deve refazer fetch se periodo nao mudou', async () => {
      setupSuccessfulMocks()
      const { result, rerender } = renderHook(() => useMarketIntelligence({ period: '30d' }))

      await waitFor(() => expect(result.current.isLoading).toBe(false))
      const initialCallCount = mockFetch.mock.calls.length

      rerender()

      // Nao deve ter feito novas chamadas
      expect(mockFetch.mock.calls.length).toBe(initialCallCount)
    })
  })
})
```

---

## Definition of Done (DoD)

### Checklist Obrigatorio

- [ ] Arquivo criado em `hooks/use-market-intelligence.ts`
- [ ] Hook exporta tipo `UseMarketIntelligenceReturn`
- [ ] Busca 3 APIs em paralelo
- [ ] Gerencia estados: isLoading, isRefreshing, error
- [ ] Funcao refresh funciona
- [ ] setPeriod refaz fetch
- [ ] setCustomPeriod funciona
- [ ] Memoizacao implementada
- [ ] Testes unitarios escritos
- [ ] Cobertura de testes >= 80%
- [ ] Zero erros de TypeScript

### Comandos de Verificacao

```bash
# Rodar testes
npm run test -- __tests__/hooks/use-market-intelligence.test.ts

# Verificar cobertura
npm run test -- __tests__/hooks/use-market-intelligence.test.ts --coverage

# Type check
npm run type-check
```

---

## Criterios de Aceitacao

| ID | Criterio | Verificacao |
|----|----------|-------------|
| AC1 | Hook existe | import funciona |
| AC2 | Busca paralela | 3 chamadas fetch simultaneas |
| AC3 | Loading state | isLoading=true durante fetch |
| AC4 | Error handling | error populado quando falha |
| AC5 | Refresh funciona | isRefreshing=true durante refresh |
| AC6 | setPeriod funciona | Muda periodo e refaz fetch |
| AC7 | Custom period | setCustomPeriod passa datas |
| AC8 | Testes passam | npm run test passa |
| AC9 | Cobertura >= 80% | Coverage report >= 80% |

---

## Exemplo de Uso

```tsx
// Em um componente React
import { useMarketIntelligence } from '@/hooks/use-market-intelligence'

export function AnalyticsDashboard() {
  const {
    overview,
    volume,
    pipeline,
    isLoading,
    isRefreshing,
    error,
    refresh,
    setPeriod,
    period,
  } = useMarketIntelligence({ period: '30d' })

  if (isLoading) return <Loading />
  if (error) return <ErrorMessage error={error} />

  return (
    <div>
      <PeriodSelector value={period} onChange={setPeriod} />
      <RefreshButton onClick={refresh} isRefreshing={isRefreshing} />

      <KPICards kpis={overview?.kpis} />
      <VolumeChart data={volume?.dados} />
      <PipelineFunnel data={pipeline?.funil} />
    </div>
  )
}
```

---

## Notas para o Desenvolvedor

1. **Parallel Fetch**: Usar Promise.all para maximizar performance
2. **Error Boundary**: Hook nao faz throw, apenas seta error state
3. **Memoizacao**: useMemo no retorno evita re-renders desnecessarios
4. **Cleanup**: Nao ha efeitos que precisem de cleanup
5. **Dependencies**: Cuidado com dependencias do useCallback para evitar loops
