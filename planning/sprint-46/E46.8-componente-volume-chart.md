# E46.8 - Componente VolumeChart

## Resumo

Criar o componente React que exibe um grafico de linha/area mostrando a evolucao de volume ao longo do tempo.

## Contexto

Este componente visualiza os dados do endpoint `/api/market-intelligence/volume`, mostrando mensagens, ofertas e vagas ao longo do tempo em um grafico interativo.

## Escopo

### Incluido
- Componente `VolumeChart`
- Grafico de area/linha com Recharts
- Toggle de series (mensagens, ofertas, vagas)
- Tooltip com detalhes
- Responsivo
- Skeleton de loading
- Testes unitarios

### Excluido
- Export de dados (CSV)
- Zoom interativo

---

## Especificacao Tecnica

### Props

```typescript
interface VolumeChartProps {
  data: VolumeDataPoint[] | null
  isLoading?: boolean
  className?: string
}

interface VolumeDataPoint {
  data: string // YYYY-MM-DD
  mensagens: number
  ofertas: number
  vagasExtraidas: number
  vagasImportadas: number
}
```

### Visual

- Grafico de area com gradiente
- 4 series: mensagens (azul), ofertas (amarelo), vagas extraidas (roxo), vagas importadas (verde)
- Eixo X: datas formatadas (DD/MM)
- Eixo Y: valores numericos
- Legenda interativa (clique para toggle)
- Tooltip no hover

---

## Implementacao

### Arquivo: `dashboard/components/market-intelligence/volume-chart.tsx`

```typescript
/**
 * VolumeChart - Sprint 46
 *
 * Grafico de area/linha mostrando evolucao de volume ao longo do tempo.
 */

'use client'

import { useState, useMemo } from 'react'
import {
  AreaChart,
  Area,
  XAxis,
  YAxis,
  CartesianGrid,
  Tooltip,
  Legend,
  ResponsiveContainer,
} from 'recharts'
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card'
import { Skeleton } from '@/components/ui/skeleton'
import { cn } from '@/lib/utils'
import type { VolumeDataPoint } from '@/types/market-intelligence'

// =============================================================================
// TYPES
// =============================================================================

export interface VolumeChartProps {
  data: VolumeDataPoint[] | null
  isLoading?: boolean
  className?: string
  title?: string
}

interface SeriesConfig {
  key: keyof Omit<VolumeDataPoint, 'data'>
  label: string
  color: string
  defaultVisible: boolean
}

// =============================================================================
// CONSTANTS
// =============================================================================

const SERIES_CONFIG: SeriesConfig[] = [
  { key: 'mensagens', label: 'Mensagens', color: '#3b82f6', defaultVisible: true },
  { key: 'ofertas', label: 'Ofertas', color: '#f59e0b', defaultVisible: true },
  { key: 'vagasExtraidas', label: 'Vagas Extraidas', color: '#8b5cf6', defaultVisible: false },
  { key: 'vagasImportadas', label: 'Vagas Importadas', color: '#10b981', defaultVisible: true },
]

// =============================================================================
// HELPERS
// =============================================================================

function formatDate(dateStr: string): string {
  const date = new Date(dateStr + 'T00:00:00')
  return date.toLocaleDateString('pt-BR', { day: '2-digit', month: '2-digit' })
}

function formatNumber(value: number): string {
  if (value >= 1000) {
    return `${(value / 1000).toFixed(1)}k`
  }
  return String(value)
}

// =============================================================================
// SUBCOMPONENTS
// =============================================================================

function VolumeChartSkeleton() {
  return (
    <Card>
      <CardHeader>
        <Skeleton className="h-6 w-40" />
      </CardHeader>
      <CardContent>
        <Skeleton className="h-[300px] w-full" />
      </CardContent>
    </Card>
  )
}

interface CustomTooltipProps {
  active?: boolean
  payload?: Array<{
    name: string
    value: number
    color: string
    dataKey: string
  }>
  label?: string
}

function CustomTooltip({ active, payload, label }: CustomTooltipProps) {
  if (!active || !payload || !payload.length) {
    return null
  }

  return (
    <div className="rounded-lg border bg-background p-3 shadow-md">
      <p className="mb-2 font-medium">{label ? formatDate(label) : ''}</p>
      <div className="space-y-1">
        {payload.map((entry) => (
          <div key={entry.dataKey} className="flex items-center justify-between gap-4">
            <div className="flex items-center gap-2">
              <div
                className="h-3 w-3 rounded-full"
                style={{ backgroundColor: entry.color }}
              />
              <span className="text-sm text-muted-foreground">{entry.name}</span>
            </div>
            <span className="font-medium">{entry.value.toLocaleString('pt-BR')}</span>
          </div>
        ))}
      </div>
    </div>
  )
}

interface LegendItemProps {
  seriesKey: string
  label: string
  color: string
  visible: boolean
  onClick: () => void
}

function LegendItem({ seriesKey, label, color, visible, onClick }: LegendItemProps) {
  return (
    <button
      type="button"
      onClick={onClick}
      className={cn(
        'flex items-center gap-2 rounded-md px-2 py-1 text-sm transition-colors',
        visible ? 'opacity-100' : 'opacity-50'
      )}
      aria-pressed={visible}
      aria-label={`${visible ? 'Ocultar' : 'Mostrar'} ${label}`}
    >
      <div
        className={cn('h-3 w-3 rounded-full', !visible && 'ring-1 ring-muted-foreground')}
        style={{ backgroundColor: visible ? color : 'transparent' }}
      />
      <span>{label}</span>
    </button>
  )
}

// =============================================================================
// MAIN COMPONENT
// =============================================================================

export function VolumeChart({
  data,
  isLoading = false,
  className,
  title = 'Volume ao Longo do Tempo',
}: VolumeChartProps) {
  // Estado de visibilidade das series
  const [visibleSeries, setVisibleSeries] = useState<Set<string>>(() => {
    const initial = new Set<string>()
    SERIES_CONFIG.forEach((s) => {
      if (s.defaultVisible) {
        initial.add(s.key)
      }
    })
    return initial
  })

  // Toggle de serie
  const toggleSeries = (key: string) => {
    setVisibleSeries((prev) => {
      const next = new Set(prev)
      if (next.has(key)) {
        // Nao permitir ocultar todas
        if (next.size > 1) {
          next.delete(key)
        }
      } else {
        next.add(key)
      }
      return next
    })
  }

  // Formatar dados para o grafico
  const chartData = useMemo(() => {
    if (!data) return []
    return data.map((d) => ({
      ...d,
      dataFormatada: formatDate(d.data),
    }))
  }, [data])

  // Loading state
  if (isLoading) {
    return <VolumeChartSkeleton />
  }

  // Empty state
  if (!data || data.length === 0) {
    return (
      <Card className={className}>
        <CardHeader>
          <CardTitle>{title}</CardTitle>
        </CardHeader>
        <CardContent>
          <div className="flex h-[300px] items-center justify-center text-muted-foreground">
            Nenhum dado disponivel para o periodo selecionado
          </div>
        </CardContent>
      </Card>
    )
  }

  return (
    <Card className={className}>
      <CardHeader className="flex flex-row items-center justify-between">
        <CardTitle>{title}</CardTitle>
        <div className="flex flex-wrap gap-1">
          {SERIES_CONFIG.map((series) => (
            <LegendItem
              key={series.key}
              seriesKey={series.key}
              label={series.label}
              color={series.color}
              visible={visibleSeries.has(series.key)}
              onClick={() => toggleSeries(series.key)}
            />
          ))}
        </div>
      </CardHeader>
      <CardContent>
        <div className="h-[300px] w-full">
          <ResponsiveContainer width="100%" height="100%">
            <AreaChart data={chartData} margin={{ top: 10, right: 10, left: 0, bottom: 0 }}>
              <defs>
                {SERIES_CONFIG.map((series) => (
                  <linearGradient
                    key={`gradient-${series.key}`}
                    id={`gradient-${series.key}`}
                    x1="0"
                    y1="0"
                    x2="0"
                    y2="1"
                  >
                    <stop offset="5%" stopColor={series.color} stopOpacity={0.3} />
                    <stop offset="95%" stopColor={series.color} stopOpacity={0} />
                  </linearGradient>
                ))}
              </defs>

              <CartesianGrid strokeDasharray="3 3" className="stroke-muted" />

              <XAxis
                dataKey="data"
                tickFormatter={formatDate}
                tick={{ fontSize: 12 }}
                tickLine={false}
                axisLine={false}
                interval="preserveStartEnd"
              />

              <YAxis
                tickFormatter={formatNumber}
                tick={{ fontSize: 12 }}
                tickLine={false}
                axisLine={false}
                width={40}
              />

              <Tooltip content={<CustomTooltip />} />

              {SERIES_CONFIG.map((series) =>
                visibleSeries.has(series.key) ? (
                  <Area
                    key={series.key}
                    type="monotone"
                    dataKey={series.key}
                    name={series.label}
                    stroke={series.color}
                    fill={`url(#gradient-${series.key})`}
                    strokeWidth={2}
                    dot={false}
                    activeDot={{ r: 4, fill: series.color }}
                  />
                ) : null
              )}
            </AreaChart>
          </ResponsiveContainer>
        </div>
      </CardContent>
    </Card>
  )
}

export default VolumeChart
```

---

## Testes

### Arquivo: `dashboard/__tests__/components/market-intelligence/volume-chart.test.tsx`

```typescript
/**
 * Testes Unitarios - VolumeChart
 */

import { render, screen, fireEvent } from '@testing-library/react'
import { VolumeChart } from '@/components/market-intelligence/volume-chart'
import type { VolumeDataPoint } from '@/types/market-intelligence'

// Mock do Recharts para evitar problemas com ResponsiveContainer
jest.mock('recharts', () => ({
  ResponsiveContainer: ({ children }: { children: React.ReactNode }) => (
    <div data-testid="responsive-container">{children}</div>
  ),
  AreaChart: ({ children, data }: { children: React.ReactNode; data: unknown[] }) => (
    <div data-testid="area-chart" data-points={data.length}>
      {children}
    </div>
  ),
  Area: ({ dataKey, name }: { dataKey: string; name: string }) => (
    <div data-testid={`area-${dataKey}`} data-name={name} />
  ),
  XAxis: () => <div data-testid="x-axis" />,
  YAxis: () => <div data-testid="y-axis" />,
  CartesianGrid: () => <div data-testid="cartesian-grid" />,
  Tooltip: () => <div data-testid="tooltip" />,
  Legend: () => <div data-testid="legend" />,
}))

// =============================================================================
// TEST DATA
// =============================================================================

const mockData: VolumeDataPoint[] = [
  { data: '2024-01-01', mensagens: 100, ofertas: 30, vagasExtraidas: 20, vagasImportadas: 15 },
  { data: '2024-01-02', mensagens: 150, ofertas: 45, vagasExtraidas: 30, vagasImportadas: 22 },
  { data: '2024-01-03', mensagens: 120, ofertas: 36, vagasExtraidas: 25, vagasImportadas: 18 },
]

// =============================================================================
// TESTS
// =============================================================================

describe('VolumeChart', () => {
  describe('Renderizacao', () => {
    it('deve renderizar o componente com dados', () => {
      render(<VolumeChart data={mockData} />)

      expect(screen.getByText('Volume ao Longo do Tempo')).toBeInTheDocument()
      expect(screen.getByTestId('area-chart')).toBeInTheDocument()
    })

    it('deve renderizar titulo customizado', () => {
      render(<VolumeChart data={mockData} title="Titulo Customizado" />)

      expect(screen.getByText('Titulo Customizado')).toBeInTheDocument()
    })

    it('deve renderizar skeleton quando isLoading=true', () => {
      render(<VolumeChart data={null} isLoading />)

      // Skeleton nao tem o titulo
      expect(screen.queryByText('Volume ao Longo do Tempo')).not.toBeInTheDocument()
    })

    it('deve renderizar empty state quando data=null', () => {
      render(<VolumeChart data={null} />)

      expect(screen.getByText(/nenhum dado disponivel/i)).toBeInTheDocument()
    })

    it('deve renderizar empty state quando data=[]', () => {
      render(<VolumeChart data={[]} />)

      expect(screen.getByText(/nenhum dado disponivel/i)).toBeInTheDocument()
    })

    it('deve aplicar className customizado', () => {
      const { container } = render(<VolumeChart data={mockData} className="custom-class" />)

      expect(container.firstChild).toHaveClass('custom-class')
    })
  })

  describe('Legenda Interativa', () => {
    it('deve renderizar botoes de legenda para cada serie', () => {
      render(<VolumeChart data={mockData} />)

      expect(screen.getByRole('button', { name: /mensagens/i })).toBeInTheDocument()
      expect(screen.getByRole('button', { name: /ofertas/i })).toBeInTheDocument()
      expect(screen.getByRole('button', { name: /vagas extraidas/i })).toBeInTheDocument()
      expect(screen.getByRole('button', { name: /vagas importadas/i })).toBeInTheDocument()
    })

    it('deve ter aria-pressed correto nos botoes de legenda', () => {
      render(<VolumeChart data={mockData} />)

      // Mensagens deve estar visivel por default
      const mensagensBtn = screen.getByRole('button', { name: /mostrar mensagens|ocultar mensagens/i })
      expect(mensagensBtn).toHaveAttribute('aria-pressed', 'true')
    })

    it('deve toggle visibilidade ao clicar na legenda', () => {
      render(<VolumeChart data={mockData} />)

      // Inicialmente mensagens visivel
      const mensagensBtn = screen.getByRole('button', { name: /ocultar mensagens/i })
      expect(mensagensBtn).toHaveAttribute('aria-pressed', 'true')

      // Clicar para ocultar
      fireEvent.click(mensagensBtn)

      // Agora deve estar oculto
      expect(mensagensBtn).toHaveAttribute('aria-pressed', 'false')
    })

    it('nao deve permitir ocultar todas as series', () => {
      render(<VolumeChart data={mockData} />)

      // Ocultar series ate ficar so uma
      const ofertasBtn = screen.getByRole('button', { name: /ocultar ofertas/i })
      const importadasBtn = screen.getByRole('button', { name: /ocultar vagas importadas/i })

      fireEvent.click(ofertasBtn)
      fireEvent.click(importadasBtn)

      // Agora so mensagens esta visivel
      const mensagensBtn = screen.getByRole('button', { name: /ocultar mensagens/i })
      expect(mensagensBtn).toHaveAttribute('aria-pressed', 'true')

      // Tentar ocultar a ultima - nao deve funcionar
      fireEvent.click(mensagensBtn)
      expect(mensagensBtn).toHaveAttribute('aria-pressed', 'true')
    })
  })

  describe('Grafico', () => {
    it('deve passar dados corretos para o grafico', () => {
      render(<VolumeChart data={mockData} />)

      const chart = screen.getByTestId('area-chart')
      expect(chart).toHaveAttribute('data-points', '3')
    })

    it('deve renderizar areas para series visiveis', () => {
      render(<VolumeChart data={mockData} />)

      // Series visiveis por default: mensagens, ofertas, vagasImportadas
      expect(screen.getByTestId('area-mensagens')).toBeInTheDocument()
      expect(screen.getByTestId('area-ofertas')).toBeInTheDocument()
      expect(screen.getByTestId('area-vagasImportadas')).toBeInTheDocument()

      // vagasExtraidas nao e visivel por default
      expect(screen.queryByTestId('area-vagasExtraidas')).not.toBeInTheDocument()
    })

    it('deve renderizar eixos', () => {
      render(<VolumeChart data={mockData} />)

      expect(screen.getByTestId('x-axis')).toBeInTheDocument()
      expect(screen.getByTestId('y-axis')).toBeInTheDocument()
    })

    it('deve renderizar grid', () => {
      render(<VolumeChart data={mockData} />)

      expect(screen.getByTestId('cartesian-grid')).toBeInTheDocument()
    })

    it('deve renderizar tooltip', () => {
      render(<VolumeChart data={mockData} />)

      expect(screen.getByTestId('tooltip')).toBeInTheDocument()
    })
  })

  describe('Acessibilidade', () => {
    it('deve ter labels descritivos nos botoes de legenda', () => {
      render(<VolumeChart data={mockData} />)

      const buttons = screen.getAllByRole('button')
      buttons.forEach((btn) => {
        expect(btn).toHaveAttribute('aria-label')
      })
    })

    it('deve ter aria-pressed em todos botoes de toggle', () => {
      render(<VolumeChart data={mockData} />)

      const buttons = screen.getAllByRole('button')
      buttons.forEach((btn) => {
        expect(btn).toHaveAttribute('aria-pressed')
      })
    })
  })

  describe('Responsividade', () => {
    it('deve usar ResponsiveContainer', () => {
      render(<VolumeChart data={mockData} />)

      expect(screen.getByTestId('responsive-container')).toBeInTheDocument()
    })
  })
})
```

---

## Definition of Done (DoD)

### Checklist Obrigatorio

- [ ] Arquivo criado em `components/market-intelligence/volume-chart.tsx`
- [ ] Componente renderiza grafico de area com Recharts
- [ ] 4 series configuradas (mensagens, ofertas, extraidas, importadas)
- [ ] Legenda interativa com toggle
- [ ] Tooltip customizado
- [ ] Skeleton de loading
- [ ] Empty state
- [ ] Responsivo
- [ ] Testes unitarios escritos
- [ ] Cobertura de testes >= 80%
- [ ] Zero erros de TypeScript

### Comandos de Verificacao

```bash
# Rodar testes
npm run test -- __tests__/components/market-intelligence/volume-chart.test.tsx

# Verificar cobertura
npm run test -- __tests__/components/market-intelligence/volume-chart.test.tsx --coverage

# Type check
npm run type-check
```

---

## Criterios de Aceitacao

| ID | Criterio | Verificacao |
|----|----------|-------------|
| AC1 | Componente existe | import funciona |
| AC2 | Renderiza grafico | AreaChart visivel com dados |
| AC3 | 4 series | Todas as series configuradas |
| AC4 | Toggle funciona | Click na legenda oculta/mostra serie |
| AC5 | Tooltip funciona | Hover mostra valores |
| AC6 | Loading state | Skeleton renderizado |
| AC7 | Empty state | Mensagem quando sem dados |
| AC8 | Responsivo | Adapta ao container |
| AC9 | Testes passam | npm run test passa |
| AC10 | Cobertura >= 80% | Coverage report >= 80% |

---

## Dependencias

```bash
# Instalar Recharts se nao estiver
npm install recharts
```

---

## Notas para o Desenvolvedor

1. **Recharts**: Usar ResponsiveContainer para graficos responsivos
2. **Cores**: Manter consistencia com design system (usar variaveis quando possivel)
3. **Performance**: useMemo para dados formatados
4. **Acessibilidade**: Botoes de legenda com aria-pressed e aria-label
5. **Gradientes**: Definir gradients em `<defs>` para reusar
