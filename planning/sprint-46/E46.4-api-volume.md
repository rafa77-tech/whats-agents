# E46.4 - API Volume

## Resumo

Criar o endpoint de API que retorna dados de volume ao longo do tempo para graficos de tendencia.

## Contexto

Este endpoint fornece dados historicos agregados por dia para visualizacao em graficos de linha/area, mostrando a evolucao de mensagens, ofertas e vagas ao longo do tempo.

## Escopo

### Incluido
- Route handler `/api/market-intelligence/volume`
- Dados diarios para graficos de tendencia
- Agregacoes por tipo (mensagens, ofertas, vagas)
- Validacao de parametros com Zod
- Testes de integracao

### Excluido
- Cache Redis (sera adicionado depois)
- Autenticacao (usa middleware existente)

---

## Especificacao Tecnica

### Endpoint

```
GET /api/market-intelligence/volume
```

### Query Parameters

| Parametro | Tipo | Obrigatorio | Default | Descricao |
|-----------|------|-------------|---------|-----------|
| period | string | Nao | '30d' | Periodo: '7d', '30d', '90d', 'custom' |
| startDate | string | Se custom | - | Data inicio (ISO: YYYY-MM-DD) |
| endDate | string | Se custom | - | Data fim (ISO: YYYY-MM-DD) |
| granularity | string | Nao | 'day' | Granularidade: 'day', 'week' |

### Response

```typescript
// 200 OK
{
  "periodo": {
    "inicio": "2024-01-01",
    "fim": "2024-01-31",
    "dias": 31
  },
  "dados": [
    {
      "data": "2024-01-01",
      "mensagens": 150,
      "ofertas": 45,
      "vagasExtraidas": 30,
      "vagasImportadas": 22
    },
    {
      "data": "2024-01-02",
      "mensagens": 180,
      "ofertas": 52,
      "vagasExtraidas": 38,
      "vagasImportadas": 28
    }
    // ... mais dias
  ],
  "totais": {
    "mensagens": 5000,
    "ofertas": 1500,
    "vagasExtraidas": 1100,
    "vagasImportadas": 850
  },
  "medias": {
    "mensagensPorDia": 161.3,
    "ofertasPorDia": 48.4,
    "vagasExtraidasPorDia": 35.5,
    "vagasImportadasPorDia": 27.4
  },
  "updatedAt": "2024-01-31T12:00:00Z"
}

// 400 Bad Request
{
  "error": "VALIDATION_ERROR",
  "message": "Parametros invalidos",
  "details": {
    "period": "Valor invalido"
  }
}

// 500 Internal Server Error
{
  "error": "DATABASE_ERROR",
  "message": "Erro ao consultar banco de dados"
}
```

---

## Implementacao

### Arquivo: `dashboard/app/api/market-intelligence/volume/route.ts`

```typescript
/**
 * API Market Intelligence Volume - Sprint 46
 *
 * Retorna dados de volume ao longo do tempo para graficos de tendencia.
 */

import { NextRequest, NextResponse } from 'next/server'
import { z } from 'zod'
import { createClient } from '@/lib/supabase/server'
import type { VolumeDataPoint, VolumeResponse } from '@/types/market-intelligence'

// =============================================================================
// VALIDACAO
// =============================================================================

const querySchema = z.object({
  period: z.enum(['7d', '30d', '90d', 'custom']).default('30d'),
  startDate: z.string().regex(/^\d{4}-\d{2}-\d{2}$/).optional(),
  endDate: z.string().regex(/^\d{4}-\d{2}-\d{2}$/).optional(),
  granularity: z.enum(['day', 'week']).default('day'),
}).refine(
  (data) => {
    if (data.period === 'custom') {
      return data.startDate && data.endDate
    }
    return true
  },
  {
    message: 'startDate e endDate sao obrigatorios quando period=custom',
  }
)

// =============================================================================
// HELPERS
// =============================================================================

function calcularPeriodo(
  period: string,
  startDate?: string,
  endDate?: string
): { inicio: Date; fim: Date; dias: number } {
  const fim = endDate ? new Date(endDate) : new Date()
  fim.setHours(23, 59, 59, 999)

  let inicio: Date

  switch (period) {
    case '7d':
      inicio = new Date(fim)
      inicio.setDate(inicio.getDate() - 6)
      break
    case '30d':
      inicio = new Date(fim)
      inicio.setDate(inicio.getDate() - 29)
      break
    case '90d':
      inicio = new Date(fim)
      inicio.setDate(inicio.getDate() - 89)
      break
    case 'custom':
      inicio = new Date(startDate!)
      break
    default:
      inicio = new Date(fim)
      inicio.setDate(inicio.getDate() - 29)
  }

  inicio.setHours(0, 0, 0, 0)

  const dias = Math.ceil((fim.getTime() - inicio.getTime()) / (1000 * 60 * 60 * 24)) + 1

  return { inicio, fim, dias }
}

function agruparPorSemana(dados: VolumeDataPoint[]): VolumeDataPoint[] {
  const semanas: Map<string, VolumeDataPoint> = new Map()

  dados.forEach((d) => {
    const date = new Date(d.data)
    // Calcular inicio da semana (domingo)
    const dayOfWeek = date.getDay()
    const startOfWeek = new Date(date)
    startOfWeek.setDate(date.getDate() - dayOfWeek)
    const weekKey = startOfWeek.toISOString().split('T')[0]

    const existing = semanas.get(weekKey) || {
      data: weekKey,
      mensagens: 0,
      ofertas: 0,
      vagasExtraidas: 0,
      vagasImportadas: 0,
    }

    semanas.set(weekKey, {
      data: weekKey,
      mensagens: existing.mensagens + d.mensagens,
      ofertas: existing.ofertas + d.ofertas,
      vagasExtraidas: existing.vagasExtraidas + d.vagasExtraidas,
      vagasImportadas: existing.vagasImportadas + d.vagasImportadas,
    })
  })

  return Array.from(semanas.values()).sort((a, b) => a.data.localeCompare(b.data))
}

// =============================================================================
// QUERIES
// =============================================================================

async function buscarDadosVolume(
  supabase: ReturnType<typeof createClient>,
  inicio: Date,
  fim: Date
): Promise<VolumeDataPoint[]> {
  const inicioStr = inicio.toISOString().split('T')[0]
  const fimStr = fim.toISOString().split('T')[0]

  // Tentar buscar da view materializada primeiro
  const { data: mvData, error: mvError } = await supabase
    .from('mv_pipeline_metrics')
    .select('*')
    .gte('data', inicioStr)
    .lte('data', fimStr)
    .order('data', { ascending: true })

  if (!mvError && mvData && mvData.length > 0) {
    return mvData.map((row) => ({
      data: row.data,
      mensagens: row.mensagens_total || 0,
      ofertas: row.mensagens_eh_oferta || 0,
      vagasExtraidas: row.vagas_extraidas || 0,
      vagasImportadas: row.vagas_importadas || 0,
    }))
  }

  // Fallback: buscar diretamente das tabelas
  return await buscarDadosDireto(supabase, inicio, fim)
}

async function buscarDadosDireto(
  supabase: ReturnType<typeof createClient>,
  inicio: Date,
  fim: Date
): Promise<VolumeDataPoint[]> {
  const inicioStr = inicio.toISOString()
  const fimStr = fim.toISOString()

  // Buscar mensagens agrupadas por dia
  const { data: mensagens, error: errMsg } = await supabase
    .from('mensagens_grupo')
    .select('created_at, eh_oferta')
    .gte('created_at', inicioStr)
    .lte('created_at', fimStr)

  if (errMsg) {
    throw new Error(`Erro ao buscar mensagens: ${errMsg.message}`)
  }

  // Buscar vagas agrupadas por dia
  const { data: vagas, error: errVagas } = await supabase
    .from('vagas_grupo')
    .select('created_at, status')
    .gte('created_at', inicioStr)
    .lte('created_at', fimStr)

  if (errVagas) {
    throw new Error(`Erro ao buscar vagas: ${errVagas.message}`)
  }

  // Agregar por dia
  const dadosPorDia: Map<string, VolumeDataPoint> = new Map()

  // Gerar todos os dias no range
  const current = new Date(inicio)
  while (current <= fim) {
    const dataStr = current.toISOString().split('T')[0]
    dadosPorDia.set(dataStr, {
      data: dataStr,
      mensagens: 0,
      ofertas: 0,
      vagasExtraidas: 0,
      vagasImportadas: 0,
    })
    current.setDate(current.getDate() + 1)
  }

  // Agregar mensagens
  (mensagens || []).forEach((m) => {
    const dataStr = new Date(m.created_at).toISOString().split('T')[0]
    const dia = dadosPorDia.get(dataStr)
    if (dia) {
      dia.mensagens++
      if (m.eh_oferta) {
        dia.ofertas++
      }
    }
  })

  // Agregar vagas
  (vagas || []).forEach((v) => {
    const dataStr = new Date(v.created_at).toISOString().split('T')[0]
    const dia = dadosPorDia.get(dataStr)
    if (dia) {
      dia.vagasExtraidas++
      if (v.status === 'importada') {
        dia.vagasImportadas++
      }
    }
  })

  return Array.from(dadosPorDia.values()).sort((a, b) => a.data.localeCompare(b.data))
}

// =============================================================================
// HANDLER
// =============================================================================

export async function GET(request: NextRequest) {
  try {
    // 1. Validar parametros
    const searchParams = Object.fromEntries(request.nextUrl.searchParams)
    const validacao = querySchema.safeParse(searchParams)

    if (!validacao.success) {
      return NextResponse.json(
        {
          error: 'VALIDATION_ERROR',
          message: 'Parametros invalidos',
          details: validacao.error.flatten().fieldErrors,
        },
        { status: 400 }
      )
    }

    const { period, startDate, endDate, granularity } = validacao.data

    // 2. Calcular periodo
    const { inicio, fim, dias } = calcularPeriodo(period, startDate, endDate)

    // 3. Buscar dados
    const supabase = createClient()
    let dados = await buscarDadosVolume(supabase, inicio, fim)

    // 4. Aplicar granularidade
    if (granularity === 'week') {
      dados = agruparPorSemana(dados)
    }

    // 5. Calcular totais e medias
    const totais = dados.reduce(
      (acc, d) => ({
        mensagens: acc.mensagens + d.mensagens,
        ofertas: acc.ofertas + d.ofertas,
        vagasExtraidas: acc.vagasExtraidas + d.vagasExtraidas,
        vagasImportadas: acc.vagasImportadas + d.vagasImportadas,
      }),
      { mensagens: 0, ofertas: 0, vagasExtraidas: 0, vagasImportadas: 0 }
    )

    const divisor = dados.length || 1
    const medias = {
      mensagensPorDia: Math.round((totais.mensagens / divisor) * 10) / 10,
      ofertasPorDia: Math.round((totais.ofertas / divisor) * 10) / 10,
      vagasExtraidasPorDia: Math.round((totais.vagasExtraidas / divisor) * 10) / 10,
      vagasImportadasPorDia: Math.round((totais.vagasImportadas / divisor) * 10) / 10,
    }

    // 6. Montar response
    const response: VolumeResponse = {
      periodo: {
        inicio: inicio.toISOString().split('T')[0],
        fim: fim.toISOString().split('T')[0],
        dias,
      },
      dados,
      totais,
      medias,
      updatedAt: new Date().toISOString(),
    }

    return NextResponse.json(response)
  } catch (error) {
    console.error('[Market Intelligence Volume] Erro:', error)

    return NextResponse.json(
      {
        error: 'INTERNAL_ERROR',
        message: 'Erro interno ao processar requisicao',
      },
      { status: 500 }
    )
  }
}
```

---

## Testes

### Arquivo: `dashboard/__tests__/api/market-intelligence/volume.test.ts`

```typescript
/**
 * Testes de Integracao - API Market Intelligence Volume
 */

import { GET } from '@/app/api/market-intelligence/volume/route'
import { NextRequest } from 'next/server'
import { createClient } from '@/lib/supabase/server'

// Mock do Supabase
jest.mock('@/lib/supabase/server', () => ({
  createClient: jest.fn(),
}))

const mockSupabase = {
  from: jest.fn().mockReturnThis(),
  select: jest.fn().mockReturnThis(),
  gte: jest.fn().mockReturnThis(),
  lte: jest.fn().mockReturnThis(),
  order: jest.fn().mockReturnThis(),
}

describe('API /api/market-intelligence/volume', () => {
  beforeEach(() => {
    jest.clearAllMocks()
    ;(createClient as jest.Mock).mockReturnValue(mockSupabase)
  })

  describe('Validacao de Parametros', () => {
    it('deve aceitar request sem parametros (usa defaults)', async () => {
      mockSupabase.order.mockResolvedValueOnce({
        data: [
          { data: '2024-01-01', mensagens_total: 100, mensagens_eh_oferta: 30, vagas_extraidas: 20, vagas_importadas: 15 },
        ],
        error: null,
      })

      const request = new NextRequest('http://localhost/api/market-intelligence/volume')
      const response = await GET(request)

      expect(response.status).toBe(200)
      const data = await response.json()
      expect(data.periodo.dias).toBe(30) // default period
    })

    it('deve aceitar period=7d', async () => {
      mockSupabase.order.mockResolvedValueOnce({ data: [], error: null })
      mockSupabase.lte.mockResolvedValueOnce({ data: [], error: null })
      mockSupabase.lte.mockResolvedValueOnce({ data: [], error: null })

      const request = new NextRequest('http://localhost/api/market-intelligence/volume?period=7d')
      const response = await GET(request)

      expect(response.status).toBe(200)
      const data = await response.json()
      expect(data.periodo.dias).toBe(7)
    })

    it('deve aceitar granularity=week', async () => {
      mockSupabase.order.mockResolvedValueOnce({
        data: [
          { data: '2024-01-01', mensagens_total: 100, mensagens_eh_oferta: 30, vagas_extraidas: 20, vagas_importadas: 15 },
          { data: '2024-01-02', mensagens_total: 110, mensagens_eh_oferta: 35, vagas_extraidas: 25, vagas_importadas: 18 },
          { data: '2024-01-08', mensagens_total: 120, mensagens_eh_oferta: 40, vagas_extraidas: 30, vagas_importadas: 22 },
        ],
        error: null,
      })

      const request = new NextRequest('http://localhost/api/market-intelligence/volume?granularity=week')
      const response = await GET(request)

      expect(response.status).toBe(200)
      const data = await response.json()
      // Dados devem estar agrupados por semana
      expect(data.dados.length).toBeLessThanOrEqual(5) // Max ~5 semanas em 30 dias
    })

    it('deve rejeitar period invalido', async () => {
      const request = new NextRequest('http://localhost/api/market-intelligence/volume?period=invalid')
      const response = await GET(request)

      expect(response.status).toBe(400)
      const data = await response.json()
      expect(data.error).toBe('VALIDATION_ERROR')
    })

    it('deve rejeitar granularity invalido', async () => {
      const request = new NextRequest('http://localhost/api/market-intelligence/volume?granularity=month')
      const response = await GET(request)

      expect(response.status).toBe(400)
      const data = await response.json()
      expect(data.error).toBe('VALIDATION_ERROR')
    })

    it('deve aceitar periodo customizado com datas validas', async () => {
      mockSupabase.order.mockResolvedValueOnce({ data: [], error: null })
      mockSupabase.lte.mockResolvedValueOnce({ data: [], error: null })
      mockSupabase.lte.mockResolvedValueOnce({ data: [], error: null })

      const request = new NextRequest(
        'http://localhost/api/market-intelligence/volume?period=custom&startDate=2024-01-01&endDate=2024-01-15'
      )
      const response = await GET(request)

      expect(response.status).toBe(200)
      const data = await response.json()
      expect(data.periodo.inicio).toBe('2024-01-01')
      expect(data.periodo.fim).toBe('2024-01-15')
      expect(data.periodo.dias).toBe(15)
    })
  })

  describe('Response Structure', () => {
    beforeEach(() => {
      mockSupabase.order.mockResolvedValue({
        data: [
          { data: '2024-01-01', mensagens_total: 100, mensagens_eh_oferta: 30, vagas_extraidas: 20, vagas_importadas: 15 },
          { data: '2024-01-02', mensagens_total: 110, mensagens_eh_oferta: 35, vagas_extraidas: 25, vagas_importadas: 18 },
        ],
        error: null,
      })
    })

    it('deve retornar estrutura de periodo correta', async () => {
      const request = new NextRequest('http://localhost/api/market-intelligence/volume')
      const response = await GET(request)
      const data = await response.json()

      expect(data.periodo).toHaveProperty('inicio')
      expect(data.periodo).toHaveProperty('fim')
      expect(data.periodo).toHaveProperty('dias')
    })

    it('deve retornar array de dados com estrutura correta', async () => {
      const request = new NextRequest('http://localhost/api/market-intelligence/volume')
      const response = await GET(request)
      const data = await response.json()

      expect(Array.isArray(data.dados)).toBe(true)
      if (data.dados.length > 0) {
        const ponto = data.dados[0]
        expect(ponto).toHaveProperty('data')
        expect(ponto).toHaveProperty('mensagens')
        expect(ponto).toHaveProperty('ofertas')
        expect(ponto).toHaveProperty('vagasExtraidas')
        expect(ponto).toHaveProperty('vagasImportadas')
      }
    })

    it('deve retornar totais agregados', async () => {
      const request = new NextRequest('http://localhost/api/market-intelligence/volume')
      const response = await GET(request)
      const data = await response.json()

      expect(data.totais).toHaveProperty('mensagens')
      expect(data.totais).toHaveProperty('ofertas')
      expect(data.totais).toHaveProperty('vagasExtraidas')
      expect(data.totais).toHaveProperty('vagasImportadas')
      expect(typeof data.totais.mensagens).toBe('number')
    })

    it('deve retornar medias calculadas', async () => {
      const request = new NextRequest('http://localhost/api/market-intelligence/volume')
      const response = await GET(request)
      const data = await response.json()

      expect(data.medias).toHaveProperty('mensagensPorDia')
      expect(data.medias).toHaveProperty('ofertasPorDia')
      expect(data.medias).toHaveProperty('vagasExtraidasPorDia')
      expect(data.medias).toHaveProperty('vagasImportadasPorDia')
      expect(typeof data.medias.mensagensPorDia).toBe('number')
    })

    it('deve retornar updatedAt', async () => {
      const request = new NextRequest('http://localhost/api/market-intelligence/volume')
      const response = await GET(request)
      const data = await response.json()

      expect(data).toHaveProperty('updatedAt')
      expect(new Date(data.updatedAt).toString()).not.toBe('Invalid Date')
    })
  })

  describe('Calculos', () => {
    it('deve calcular totais corretamente', async () => {
      mockSupabase.order.mockResolvedValue({
        data: [
          { data: '2024-01-01', mensagens_total: 100, mensagens_eh_oferta: 30, vagas_extraidas: 20, vagas_importadas: 15 },
          { data: '2024-01-02', mensagens_total: 150, mensagens_eh_oferta: 45, vagas_extraidas: 35, vagas_importadas: 25 },
        ],
        error: null,
      })

      const request = new NextRequest('http://localhost/api/market-intelligence/volume')
      const response = await GET(request)
      const data = await response.json()

      expect(data.totais.mensagens).toBe(250) // 100 + 150
      expect(data.totais.ofertas).toBe(75) // 30 + 45
      expect(data.totais.vagasExtraidas).toBe(55) // 20 + 35
      expect(data.totais.vagasImportadas).toBe(40) // 15 + 25
    })

    it('deve calcular medias corretamente', async () => {
      mockSupabase.order.mockResolvedValue({
        data: [
          { data: '2024-01-01', mensagens_total: 100, mensagens_eh_oferta: 30, vagas_extraidas: 20, vagas_importadas: 10 },
          { data: '2024-01-02', mensagens_total: 200, mensagens_eh_oferta: 70, vagas_extraidas: 40, vagas_importadas: 30 },
        ],
        error: null,
      })

      const request = new NextRequest('http://localhost/api/market-intelligence/volume')
      const response = await GET(request)
      const data = await response.json()

      expect(data.medias.mensagensPorDia).toBe(150) // (100 + 200) / 2
      expect(data.medias.ofertasPorDia).toBe(50) // (30 + 70) / 2
    })

    it('deve agrupar por semana corretamente', async () => {
      // Dados de duas semanas diferentes
      mockSupabase.order.mockResolvedValue({
        data: [
          { data: '2024-01-01', mensagens_total: 100, mensagens_eh_oferta: 30, vagas_extraidas: 20, vagas_importadas: 15 }, // Semana 1
          { data: '2024-01-02', mensagens_total: 100, mensagens_eh_oferta: 30, vagas_extraidas: 20, vagas_importadas: 15 }, // Semana 1
          { data: '2024-01-08', mensagens_total: 200, mensagens_eh_oferta: 60, vagas_extraidas: 40, vagas_importadas: 30 }, // Semana 2
        ],
        error: null,
      })

      const request = new NextRequest('http://localhost/api/market-intelligence/volume?granularity=week')
      const response = await GET(request)
      const data = await response.json()

      expect(data.dados.length).toBe(2) // 2 semanas distintas
    })
  })

  describe('Tratamento de Erros', () => {
    it('deve retornar 500 quando view materializada falha e fallback tambem falha', async () => {
      mockSupabase.order.mockResolvedValue({ data: null, error: { message: 'MV error' } })
      mockSupabase.lte.mockResolvedValue({ data: null, error: { message: 'DB error' } })

      const request = new NextRequest('http://localhost/api/market-intelligence/volume')
      const response = await GET(request)

      expect(response.status).toBe(500)
      const data = await response.json()
      expect(data.error).toBe('INTERNAL_ERROR')
    })

    it('deve usar fallback quando view materializada esta vazia', async () => {
      // MV retorna vazio
      mockSupabase.order.mockResolvedValueOnce({ data: [], error: null })
      // Fallback retorna dados
      mockSupabase.lte.mockResolvedValueOnce({
        data: [{ created_at: '2024-01-01T10:00:00Z', eh_oferta: true }],
        error: null,
      })
      mockSupabase.lte.mockResolvedValueOnce({
        data: [{ created_at: '2024-01-01T10:00:00Z', status: 'importada' }],
        error: null,
      })

      const request = new NextRequest('http://localhost/api/market-intelligence/volume')
      const response = await GET(request)

      expect(response.status).toBe(200)
    })
  })

  describe('Dados vazios', () => {
    it('deve retornar estrutura valida mesmo sem dados', async () => {
      mockSupabase.order.mockResolvedValue({ data: [], error: null })
      mockSupabase.lte.mockResolvedValueOnce({ data: [], error: null })
      mockSupabase.lte.mockResolvedValueOnce({ data: [], error: null })

      const request = new NextRequest('http://localhost/api/market-intelligence/volume')
      const response = await GET(request)

      expect(response.status).toBe(200)
      const data = await response.json()
      expect(Array.isArray(data.dados)).toBe(true)
      expect(data.totais.mensagens).toBe(0)
    })
  })
})
```

---

## Definition of Done (DoD)

### Checklist Obrigatorio

- [ ] Arquivo criado em `app/api/market-intelligence/volume/route.ts`
- [ ] Validacao com Zod implementada
- [ ] Parametro granularity funcionando (day/week)
- [ ] Response segue exatamente o schema definido
- [ ] Totais e medias calculados corretamente
- [ ] Fallback para tabelas originais quando MV vazia
- [ ] Testes de integracao escritos
- [ ] Cobertura de testes >= 80%
- [ ] Endpoint responde em < 500ms
- [ ] Zero erros de TypeScript

### Comandos de Verificacao

```bash
# Rodar testes
npm run test -- __tests__/api/market-intelligence/volume.test.ts

# Verificar cobertura
npm run test -- __tests__/api/market-intelligence/volume.test.ts --coverage

# Testar endpoint manualmente
curl "http://localhost:3000/api/market-intelligence/volume?period=30d"

# Testar com granularidade semanal
curl "http://localhost:3000/api/market-intelligence/volume?period=90d&granularity=week"
```

---

## Criterios de Aceitacao

| ID | Criterio | Verificacao |
|----|----------|-------------|
| AC1 | Endpoint existe | GET /api/market-intelligence/volume retorna 200 |
| AC2 | Valida parametros | period=invalid retorna 400 |
| AC3 | Retorna dados diarios | dados[] contem objetos com data, mensagens, etc |
| AC4 | Granularidade funciona | granularity=week agrupa por semana |
| AC5 | Calcula totais | totais contem soma de todos os valores |
| AC6 | Calcula medias | medias contem valores por dia |
| AC7 | Performance OK | Response time < 500ms |
| AC8 | Testes passam | npm run test passa |
| AC9 | Cobertura >= 80% | Coverage report >= 80% |

---

## Notas para o Desenvolvedor

1. **View Materializada**: Priorizar `mv_pipeline_metrics` para performance
2. **Fallback**: Se MV vazia, buscar de `mensagens_grupo` e `vagas_grupo` diretamente
3. **Granularidade**: Agrupamento semanal usa domingo como inicio da semana
4. **Zeros**: Preencher dias sem dados com zeros para continuidade do grafico
5. **Performance**: Limitar a 90 dias max para evitar queries pesadas
