# E46.9 - Componente PipelineFunnel

## Resumo

Criar o componente React que exibe o funil de processamento do pipeline em formato visual.

## Contexto

Este componente visualiza os dados do endpoint `/api/market-intelligence/pipeline`, mostrando cada etapa do funil (mensagens → ofertas → vagas) com valores absolutos e percentuais.

## Escopo

### Incluido
- Componente `PipelineFunnel`
- Visualizacao em barras horizontais decrescentes
- Percentuais e valores absolutos
- Taxas de conversao entre etapas
- Tooltip com detalhes
- Skeleton de loading
- Testes unitarios

### Excluido
- Animacoes de transicao
- Drill-down por etapa

---

## Especificacao Tecnica

### Props

```typescript
interface PipelineFunnelProps {
  data: PipelineFunnel | null
  perdas?: PipelinePerdas | null
  isLoading?: boolean
  className?: string
}

interface PipelineFunnel {
  etapas: PipelineEtapa[]
  conversoes: PipelineConversoes
}

interface PipelineEtapa {
  id: string
  nome: string
  valor: number
  percentual: number
}

interface PipelineConversoes {
  mensagemParaOferta: number
  ofertaParaExtracao: number
  extracaoParaImportacao: number
  totalPipeline: number
}

interface PipelinePerdas {
  duplicadas: number
  descartadas: number
  revisao: number
  semDadosMinimos: number
}
```

### Visual

- Barras horizontais com largura proporcional ao percentual
- Cores degradando de azul claro (inicio) para verde (fim)
- Setas indicando fluxo
- Taxa de conversao entre cada etapa
- Card de perdas separado

---

## Implementacao

### Arquivo: `dashboard/components/market-intelligence/pipeline-funnel.tsx`

```typescript
/**
 * PipelineFunnel - Sprint 46
 *
 * Visualizacao do funil de processamento do pipeline.
 */

'use client'

import { useMemo } from 'react'
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card'
import { Skeleton } from '@/components/ui/skeleton'
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from '@/components/ui/tooltip'
import { cn } from '@/lib/utils'
import { ArrowDown, AlertTriangle, CheckCircle2, XCircle } from 'lucide-react'
import type {
  PipelineFunil,
  PipelineEtapa,
  PipelineConversoes,
  PipelinePerdas,
} from '@/types/market-intelligence'

// =============================================================================
// TYPES
// =============================================================================

export interface PipelineFunnelProps {
  data: PipelineFunil | null
  perdas?: PipelinePerdas | null
  isLoading?: boolean
  className?: string
  title?: string
  showPerdas?: boolean
}

// =============================================================================
// CONSTANTS
// =============================================================================

const STAGE_COLORS: Record<string, string> = {
  mensagens: 'bg-blue-500',
  heuristica: 'bg-blue-400',
  ofertas: 'bg-indigo-500',
  extraidas: 'bg-violet-500',
  validadas: 'bg-purple-500',
  importadas: 'bg-green-500',
}

const STAGE_BG_COLORS: Record<string, string> = {
  mensagens: 'bg-blue-100 dark:bg-blue-950',
  heuristica: 'bg-blue-50 dark:bg-blue-950',
  ofertas: 'bg-indigo-100 dark:bg-indigo-950',
  extraidas: 'bg-violet-100 dark:bg-violet-950',
  validadas: 'bg-purple-100 dark:bg-purple-950',
  importadas: 'bg-green-100 dark:bg-green-950',
}

// =============================================================================
// HELPERS
// =============================================================================

function formatNumber(value: number): string {
  return value.toLocaleString('pt-BR')
}

function formatPercent(value: number): string {
  return `${value.toFixed(1)}%`
}

// =============================================================================
// SUBCOMPONENTS
// =============================================================================

function PipelineFunnelSkeleton() {
  return (
    <Card>
      <CardHeader>
        <Skeleton className="h-6 w-40" />
      </CardHeader>
      <CardContent className="space-y-4">
        {[100, 80, 60, 40, 30, 20].map((width, i) => (
          <div key={i} className="space-y-2">
            <Skeleton className="h-4 w-24" />
            <Skeleton className="h-10" style={{ width: `${width}%` }} />
          </div>
        ))}
      </CardContent>
    </Card>
  )
}

interface FunnelStageProps {
  etapa: PipelineEtapa
  isFirst: boolean
  isLast: boolean
  conversaoProxima?: number
}

function FunnelStage({ etapa, isFirst, isLast, conversaoProxima }: FunnelStageProps) {
  const barColor = STAGE_COLORS[etapa.id] || 'bg-gray-500'
  const bgColor = STAGE_BG_COLORS[etapa.id] || 'bg-gray-100'

  return (
    <div className="space-y-1">
      {/* Label */}
      <div className="flex items-center justify-between text-sm">
        <span className="font-medium">{etapa.nome}</span>
        <span className="text-muted-foreground">
          {formatNumber(etapa.valor)} ({formatPercent(etapa.percentual)})
        </span>
      </div>

      {/* Bar */}
      <TooltipProvider>
        <Tooltip>
          <TooltipTrigger asChild>
            <div className={cn('h-10 rounded-md transition-all', bgColor)}>
              <div
                className={cn(
                  'h-full rounded-md flex items-center justify-center text-white font-medium text-sm transition-all',
                  barColor
                )}
                style={{ width: `${Math.max(etapa.percentual, 5)}%` }}
              >
                {etapa.percentual >= 15 && formatPercent(etapa.percentual)}
              </div>
            </div>
          </TooltipTrigger>
          <TooltipContent>
            <div className="space-y-1">
              <p className="font-medium">{etapa.nome}</p>
              <p>Total: {formatNumber(etapa.valor)}</p>
              <p>Percentual: {formatPercent(etapa.percentual)}</p>
            </div>
          </TooltipContent>
        </Tooltip>
      </TooltipProvider>

      {/* Conversion arrow */}
      {!isLast && conversaoProxima !== undefined && (
        <div className="flex items-center justify-center py-1 text-muted-foreground">
          <ArrowDown className="h-4 w-4" />
          <span className="ml-1 text-xs">{formatPercent(conversaoProxima)} convertido</span>
        </div>
      )}
    </div>
  )
}

interface PerdasCardProps {
  perdas: PipelinePerdas
}

function PerdasCard({ perdas }: PerdasCardProps) {
  const items = [
    { label: 'Duplicadas', value: perdas.duplicadas, icon: XCircle, color: 'text-orange-500' },
    { label: 'Descartadas', value: perdas.descartadas, icon: XCircle, color: 'text-red-500' },
    { label: 'Em Revisao', value: perdas.revisao, icon: AlertTriangle, color: 'text-yellow-500' },
    {
      label: 'Sem Dados Minimos',
      value: perdas.semDadosMinimos,
      icon: AlertTriangle,
      color: 'text-orange-500',
    },
  ]

  const total = items.reduce((acc, item) => acc + item.value, 0)

  return (
    <Card>
      <CardHeader className="pb-2">
        <CardTitle className="text-base">Perdas no Pipeline</CardTitle>
      </CardHeader>
      <CardContent>
        <div className="space-y-3">
          {items.map((item) => {
            const Icon = item.icon
            return (
              <div key={item.label} className="flex items-center justify-between">
                <div className="flex items-center gap-2">
                  <Icon className={cn('h-4 w-4', item.color)} />
                  <span className="text-sm">{item.label}</span>
                </div>
                <span className="font-medium">{formatNumber(item.value)}</span>
              </div>
            )
          })}
          <div className="border-t pt-2 flex items-center justify-between">
            <span className="text-sm font-medium">Total de Perdas</span>
            <span className="font-bold">{formatNumber(total)}</span>
          </div>
        </div>
      </CardContent>
    </Card>
  )
}

interface ConversaoResumoProps {
  conversoes: PipelineConversoes
}

function ConversaoResumo({ conversoes }: ConversaoResumoProps) {
  return (
    <Card>
      <CardHeader className="pb-2">
        <CardTitle className="text-base">Taxas de Conversao</CardTitle>
      </CardHeader>
      <CardContent>
        <div className="grid grid-cols-2 gap-4">
          <div className="space-y-1">
            <p className="text-xs text-muted-foreground">Msg → Oferta</p>
            <p className="text-lg font-bold">{formatPercent(conversoes.mensagemParaOferta)}</p>
          </div>
          <div className="space-y-1">
            <p className="text-xs text-muted-foreground">Oferta → Extracao</p>
            <p className="text-lg font-bold">{formatPercent(conversoes.ofertaParaExtracao)}</p>
          </div>
          <div className="space-y-1">
            <p className="text-xs text-muted-foreground">Extracao → Import</p>
            <p className="text-lg font-bold">{formatPercent(conversoes.extracaoParaImportacao)}</p>
          </div>
          <div className="space-y-1">
            <p className="text-xs text-muted-foreground">Pipeline Total</p>
            <p className="text-lg font-bold text-green-600">{formatPercent(conversoes.totalPipeline)}</p>
          </div>
        </div>
      </CardContent>
    </Card>
  )
}

// =============================================================================
// MAIN COMPONENT
// =============================================================================

export function PipelineFunnel({
  data,
  perdas,
  isLoading = false,
  className,
  title = 'Funil do Pipeline',
  showPerdas = true,
}: PipelineFunnelProps) {
  // Calcular conversoes entre etapas adjacentes
  const etapasComConversao = useMemo(() => {
    if (!data?.etapas) return []

    return data.etapas.map((etapa, index) => {
      let conversaoProxima: number | undefined

      if (index < data.etapas.length - 1) {
        const proxima = data.etapas[index + 1]
        if (etapa.valor > 0) {
          conversaoProxima = (proxima.valor / etapa.valor) * 100
        }
      }

      return { etapa, conversaoProxima }
    })
  }, [data])

  // Loading state
  if (isLoading) {
    return <PipelineFunnelSkeleton />
  }

  // Empty state
  if (!data || !data.etapas || data.etapas.length === 0) {
    return (
      <Card className={className}>
        <CardHeader>
          <CardTitle>{title}</CardTitle>
        </CardHeader>
        <CardContent>
          <div className="flex h-[200px] items-center justify-center text-muted-foreground">
            Nenhum dado disponivel para o periodo selecionado
          </div>
        </CardContent>
      </Card>
    )
  }

  return (
    <div className={cn('space-y-4', className)}>
      {/* Funil Principal */}
      <Card>
        <CardHeader>
          <CardTitle>{title}</CardTitle>
        </CardHeader>
        <CardContent className="space-y-4">
          {etapasComConversao.map(({ etapa, conversaoProxima }, index) => (
            <FunnelStage
              key={etapa.id}
              etapa={etapa}
              isFirst={index === 0}
              isLast={index === etapasComConversao.length - 1}
              conversaoProxima={conversaoProxima}
            />
          ))}
        </CardContent>
      </Card>

      {/* Cards Auxiliares */}
      <div className="grid gap-4 md:grid-cols-2">
        {data.conversoes && <ConversaoResumo conversoes={data.conversoes} />}
        {showPerdas && perdas && <PerdasCard perdas={perdas} />}
      </div>
    </div>
  )
}

export default PipelineFunnel
```

---

## Testes

### Arquivo: `dashboard/__tests__/components/market-intelligence/pipeline-funnel.test.tsx`

```typescript
/**
 * Testes Unitarios - PipelineFunnel
 */

import { render, screen } from '@testing-library/react'
import userEvent from '@testing-library/user-event'
import { PipelineFunnel } from '@/components/market-intelligence/pipeline-funnel'
import type { PipelineFunil, PipelinePerdas } from '@/types/market-intelligence'

// =============================================================================
// TEST DATA
// =============================================================================

const mockFunnelData: PipelineFunil = {
  etapas: [
    { id: 'mensagens', nome: 'Mensagens Recebidas', valor: 5000, percentual: 100 },
    { id: 'heuristica', nome: 'Passou Heuristica', valor: 2000, percentual: 40 },
    { id: 'ofertas', nome: 'Classificadas como Oferta', valor: 1500, percentual: 30 },
    { id: 'extraidas', nome: 'Vagas Extraidas', valor: 1100, percentual: 22 },
    { id: 'validadas', nome: 'Dados Minimos OK', valor: 950, percentual: 19 },
    { id: 'importadas', nome: 'Vagas Importadas', valor: 850, percentual: 17 },
  ],
  conversoes: {
    mensagemParaOferta: 30.0,
    ofertaParaExtracao: 73.3,
    extracaoParaImportacao: 77.3,
    totalPipeline: 17.0,
  },
}

const mockPerdas: PipelinePerdas = {
  duplicadas: 150,
  descartadas: 100,
  revisao: 50,
  semDadosMinimos: 150,
}

// =============================================================================
// TESTS
// =============================================================================

describe('PipelineFunnel', () => {
  describe('Renderizacao', () => {
    it('deve renderizar o componente com dados', () => {
      render(<PipelineFunnel data={mockFunnelData} />)

      expect(screen.getByText('Funil do Pipeline')).toBeInTheDocument()
    })

    it('deve renderizar titulo customizado', () => {
      render(<PipelineFunnel data={mockFunnelData} title="Titulo Customizado" />)

      expect(screen.getByText('Titulo Customizado')).toBeInTheDocument()
    })

    it('deve renderizar skeleton quando isLoading=true', () => {
      render(<PipelineFunnel data={null} isLoading />)

      expect(screen.queryByText('Funil do Pipeline')).not.toBeInTheDocument()
    })

    it('deve renderizar empty state quando data=null', () => {
      render(<PipelineFunnel data={null} />)

      expect(screen.getByText(/nenhum dado disponivel/i)).toBeInTheDocument()
    })

    it('deve aplicar className customizado', () => {
      const { container } = render(
        <PipelineFunnel data={mockFunnelData} className="custom-class" />
      )

      expect(container.firstChild).toHaveClass('custom-class')
    })
  })

  describe('Etapas do Funil', () => {
    it('deve renderizar todas as etapas', () => {
      render(<PipelineFunnel data={mockFunnelData} />)

      expect(screen.getByText('Mensagens Recebidas')).toBeInTheDocument()
      expect(screen.getByText('Passou Heuristica')).toBeInTheDocument()
      expect(screen.getByText('Classificadas como Oferta')).toBeInTheDocument()
      expect(screen.getByText('Vagas Extraidas')).toBeInTheDocument()
      expect(screen.getByText('Dados Minimos OK')).toBeInTheDocument()
      expect(screen.getByText('Vagas Importadas')).toBeInTheDocument()
    })

    it('deve exibir valores e percentuais', () => {
      render(<PipelineFunnel data={mockFunnelData} />)

      // Verificar formato: "5.000 (100.0%)"
      expect(screen.getByText(/5\.000/)).toBeInTheDocument()
      expect(screen.getByText(/100\.0%/)).toBeInTheDocument()
    })

    it('deve exibir setas de conversao entre etapas', () => {
      render(<PipelineFunnel data={mockFunnelData} />)

      // Deve ter setas com texto "convertido"
      const arrows = screen.getAllByText(/convertido/i)
      expect(arrows.length).toBeGreaterThan(0)
    })
  })

  describe('Card de Conversoes', () => {
    it('deve renderizar card de taxas de conversao', () => {
      render(<PipelineFunnel data={mockFunnelData} />)

      expect(screen.getByText('Taxas de Conversao')).toBeInTheDocument()
    })

    it('deve exibir todas as taxas', () => {
      render(<PipelineFunnel data={mockFunnelData} />)

      expect(screen.getByText('Msg → Oferta')).toBeInTheDocument()
      expect(screen.getByText('Oferta → Extracao')).toBeInTheDocument()
      expect(screen.getByText('Extracao → Import')).toBeInTheDocument()
      expect(screen.getByText('Pipeline Total')).toBeInTheDocument()
    })

    it('deve exibir valores corretos das taxas', () => {
      render(<PipelineFunnel data={mockFunnelData} />)

      expect(screen.getByText('30.0%')).toBeInTheDocument()
      expect(screen.getByText('73.3%')).toBeInTheDocument()
      expect(screen.getByText('77.3%')).toBeInTheDocument()
      expect(screen.getByText('17.0%')).toBeInTheDocument()
    })
  })

  describe('Card de Perdas', () => {
    it('deve renderizar card de perdas quando showPerdas=true e perdas fornecidas', () => {
      render(<PipelineFunnel data={mockFunnelData} perdas={mockPerdas} showPerdas />)

      expect(screen.getByText('Perdas no Pipeline')).toBeInTheDocument()
    })

    it('nao deve renderizar card de perdas quando showPerdas=false', () => {
      render(<PipelineFunnel data={mockFunnelData} perdas={mockPerdas} showPerdas={false} />)

      expect(screen.queryByText('Perdas no Pipeline')).not.toBeInTheDocument()
    })

    it('deve exibir todas as categorias de perda', () => {
      render(<PipelineFunnel data={mockFunnelData} perdas={mockPerdas} />)

      expect(screen.getByText('Duplicadas')).toBeInTheDocument()
      expect(screen.getByText('Descartadas')).toBeInTheDocument()
      expect(screen.getByText('Em Revisao')).toBeInTheDocument()
      expect(screen.getByText('Sem Dados Minimos')).toBeInTheDocument()
    })

    it('deve exibir valores corretos das perdas', () => {
      render(<PipelineFunnel data={mockFunnelData} perdas={mockPerdas} />)

      expect(screen.getByText('150')).toBeInTheDocument() // duplicadas e semDadosMinimos
      expect(screen.getByText('100')).toBeInTheDocument() // descartadas
      expect(screen.getByText('50')).toBeInTheDocument() // revisao
    })

    it('deve calcular e exibir total de perdas', () => {
      render(<PipelineFunnel data={mockFunnelData} perdas={mockPerdas} />)

      expect(screen.getByText('Total de Perdas')).toBeInTheDocument()
      expect(screen.getByText('450')).toBeInTheDocument() // 150+100+50+150
    })
  })

  describe('Barras do Funil', () => {
    it('deve ter barras com largura proporcional ao percentual', () => {
      render(<PipelineFunnel data={mockFunnelData} />)

      // Verificar que as barras existem (via role ou estrutura)
      const etapas = screen.getAllByText(/Mensagens|Heuristica|Oferta|Extraidas|Validadas|Importadas/)
      expect(etapas.length).toBeGreaterThan(0)
    })
  })

  describe('Tooltip', () => {
    it('deve ter tooltips nas barras', async () => {
      const user = userEvent.setup()
      render(<PipelineFunnel data={mockFunnelData} />)

      // Os tooltips existem mas precisam de hover para mostrar conteudo
      // Verificamos que a estrutura de tooltip existe
      const tooltipTriggers = document.querySelectorAll('[data-state]')
      expect(tooltipTriggers.length).toBeGreaterThan(0)
    })
  })

  describe('Edge Cases', () => {
    it('deve lidar com etapas vazias', () => {
      const emptyData: PipelineFunil = {
        etapas: [],
        conversoes: {
          mensagemParaOferta: 0,
          ofertaParaExtracao: 0,
          extracaoParaImportacao: 0,
          totalPipeline: 0,
        },
      }

      render(<PipelineFunnel data={emptyData} />)

      expect(screen.getByText(/nenhum dado disponivel/i)).toBeInTheDocument()
    })

    it('deve lidar com valores zero', () => {
      const zeroData: PipelineFunil = {
        etapas: [
          { id: 'mensagens', nome: 'Mensagens', valor: 0, percentual: 100 },
          { id: 'ofertas', nome: 'Ofertas', valor: 0, percentual: 0 },
        ],
        conversoes: {
          mensagemParaOferta: 0,
          ofertaParaExtracao: 0,
          extracaoParaImportacao: 0,
          totalPipeline: 0,
        },
      }

      render(<PipelineFunnel data={zeroData} />)

      expect(screen.getByText('Mensagens')).toBeInTheDocument()
      expect(screen.getByText('Ofertas')).toBeInTheDocument()
    })

    it('deve lidar com perdas undefined', () => {
      render(<PipelineFunnel data={mockFunnelData} perdas={undefined} />)

      expect(screen.queryByText('Perdas no Pipeline')).not.toBeInTheDocument()
    })
  })

  describe('Acessibilidade', () => {
    it('deve ter estrutura semantica correta', () => {
      render(<PipelineFunnel data={mockFunnelData} perdas={mockPerdas} />)

      // Verificar que ha titulos de card
      const titles = screen.getAllByRole('heading')
      expect(titles.length).toBeGreaterThan(0)
    })
  })
})
```

---

## Definition of Done (DoD)

### Checklist Obrigatorio

- [ ] Arquivo criado em `components/market-intelligence/pipeline-funnel.tsx`
- [ ] Componente renderiza todas as 6 etapas do funil
- [ ] Barras com largura proporcional ao percentual
- [ ] Tooltips funcionando
- [ ] Card de conversoes renderizado
- [ ] Card de perdas renderizado (quando showPerdas=true)
- [ ] Skeleton de loading
- [ ] Empty state
- [ ] Testes unitarios escritos
- [ ] Cobertura de testes >= 80%
- [ ] Zero erros de TypeScript

### Comandos de Verificacao

```bash
# Rodar testes
npm run test -- __tests__/components/market-intelligence/pipeline-funnel.test.tsx

# Verificar cobertura
npm run test -- __tests__/components/market-intelligence/pipeline-funnel.test.tsx --coverage

# Type check
npm run type-check
```

---

## Criterios de Aceitacao

| ID | Criterio | Verificacao |
|----|----------|-------------|
| AC1 | Componente existe | import funciona |
| AC2 | Renderiza 6 etapas | Todas etapas visiveis |
| AC3 | Barras proporcionais | Largura = percentual |
| AC4 | Conversoes exibidas | 4 taxas no card |
| AC5 | Perdas exibidas | 4 categorias no card |
| AC6 | Tooltips funcionam | Hover mostra detalhes |
| AC7 | Loading state | Skeleton renderizado |
| AC8 | Empty state | Mensagem quando sem dados |
| AC9 | Testes passam | npm run test passa |
| AC10 | Cobertura >= 80% | Coverage report >= 80% |

---

## Notas para o Desenvolvedor

1. **Cores**: Usar escala de cores que indica progressao (azul → verde)
2. **Percentuais**: Sempre relativo a primeira etapa (100%)
3. **Barras**: Minimo de 5% de largura para etapas com valores baixos
4. **Tooltips**: Usar TooltipProvider do shadcn/ui
5. **Responsividade**: Grid adapta em telas menores
