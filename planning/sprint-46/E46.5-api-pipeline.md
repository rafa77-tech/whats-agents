# E46.5 - API Pipeline

## Resumo

Criar o endpoint de API que retorna metricas do funil de processamento do pipeline de grupos.

## Contexto

Este endpoint fornece dados sobre cada etapa do pipeline: mensagens recebidas → ofertas detectadas → vagas extraidas → vagas importadas. Sera usado para visualizar o funil de conversao.

## Escopo

### Incluido
- Route handler `/api/market-intelligence/pipeline`
- Metricas por etapa do funil
- Taxas de conversao entre etapas
- Historico por periodo
- Validacao de parametros com Zod
- Testes de integracao

### Excluido
- Cache Redis (sera adicionado depois)
- Detalhamento por grupo (sera API separada)

---

## Especificacao Tecnica

### Endpoint

```
GET /api/market-intelligence/pipeline
```

### Query Parameters

| Parametro | Tipo | Obrigatorio | Default | Descricao |
|-----------|------|-------------|---------|-----------|
| period | string | Nao | '30d' | Periodo: '7d', '30d', '90d', 'custom' |
| startDate | string | Se custom | - | Data inicio (ISO: YYYY-MM-DD) |
| endDate | string | Se custom | - | Data fim (ISO: YYYY-MM-DD) |

### Response

```typescript
// 200 OK
{
  "periodo": {
    "inicio": "2024-01-01",
    "fim": "2024-01-31",
    "dias": 31
  },
  "funil": {
    "etapas": [
      {
        "id": "mensagens",
        "nome": "Mensagens Recebidas",
        "valor": 5000,
        "percentual": 100
      },
      {
        "id": "heuristica",
        "nome": "Passou Heuristica",
        "valor": 2000,
        "percentual": 40
      },
      {
        "id": "ofertas",
        "nome": "Classificadas como Oferta",
        "valor": 1500,
        "percentual": 30
      },
      {
        "id": "extraidas",
        "nome": "Vagas Extraidas",
        "valor": 1100,
        "percentual": 22
      },
      {
        "id": "validadas",
        "nome": "Dados Minimos OK",
        "valor": 950,
        "percentual": 19
      },
      {
        "id": "importadas",
        "nome": "Vagas Importadas",
        "valor": 850,
        "percentual": 17
      }
    ],
    "conversoes": {
      "mensagemParaOferta": 30.0,
      "ofertaParaExtracao": 73.3,
      "extracaoParaImportacao": 77.3,
      "totalPipeline": 17.0
    }
  },
  "perdas": {
    "duplicadas": 150,
    "descartadas": 100,
    "revisao": 50,
    "semDadosMinimos": 150
  },
  "qualidade": {
    "confiancaClassificacaoMedia": 0.87,
    "confiancaExtracaoMedia": 0.82
  },
  "updatedAt": "2024-01-31T12:00:00Z"
}

// 400 Bad Request
{
  "error": "VALIDATION_ERROR",
  "message": "Parametros invalidos",
  "details": { ... }
}
```

---

## Implementacao

### Arquivo: `dashboard/app/api/market-intelligence/pipeline/route.ts`

```typescript
/**
 * API Market Intelligence Pipeline - Sprint 46
 *
 * Retorna metricas do funil de processamento do pipeline de grupos.
 */

import { NextRequest, NextResponse } from 'next/server'
import { z } from 'zod'
import { createClient } from '@/lib/supabase/server'
import type {
  PipelineResponse,
  PipelineEtapa,
  PipelineConversoes,
  PipelinePerdas,
} from '@/types/market-intelligence'

// =============================================================================
// VALIDACAO
// =============================================================================

const querySchema = z.object({
  period: z.enum(['7d', '30d', '90d', 'custom']).default('30d'),
  startDate: z.string().regex(/^\d{4}-\d{2}-\d{2}$/).optional(),
  endDate: z.string().regex(/^\d{4}-\d{2}-\d{2}$/).optional(),
}).refine(
  (data) => {
    if (data.period === 'custom') {
      return data.startDate && data.endDate
    }
    return true
  },
  {
    message: 'startDate e endDate sao obrigatorios quando period=custom',
  }
)

// =============================================================================
// HELPERS
// =============================================================================

function calcularPeriodo(
  period: string,
  startDate?: string,
  endDate?: string
): { inicio: Date; fim: Date; dias: number } {
  const fim = endDate ? new Date(endDate) : new Date()
  fim.setHours(23, 59, 59, 999)

  let inicio: Date

  switch (period) {
    case '7d':
      inicio = new Date(fim)
      inicio.setDate(inicio.getDate() - 6)
      break
    case '30d':
      inicio = new Date(fim)
      inicio.setDate(inicio.getDate() - 29)
      break
    case '90d':
      inicio = new Date(fim)
      inicio.setDate(inicio.getDate() - 89)
      break
    case 'custom':
      inicio = new Date(startDate!)
      break
    default:
      inicio = new Date(fim)
      inicio.setDate(inicio.getDate() - 29)
  }

  inicio.setHours(0, 0, 0, 0)
  const dias = Math.ceil((fim.getTime() - inicio.getTime()) / (1000 * 60 * 60 * 24)) + 1

  return { inicio, fim, dias }
}

function calcularPercentual(valor: number, base: number): number {
  if (base === 0) return 0
  return Math.round((valor / base) * 1000) / 10
}

function calcularTaxaConversao(valorFinal: number, valorInicial: number): number {
  if (valorInicial === 0) return 0
  return Math.round((valorFinal / valorInicial) * 1000) / 10
}

// =============================================================================
// QUERIES
// =============================================================================

interface MetricasPipeline {
  mensagensTotal: number
  mensagensPassouHeuristica: number
  mensagensEhOferta: number
  vagasExtraidas: number
  vagasDadosOk: number
  vagasImportadas: number
  vagasDuplicadas: number
  vagasDescartadas: number
  vagasRevisao: number
  confiancaClassificacaoMedia: number | null
  confiancaExtracaoMedia: number | null
}

async function buscarMetricasPipeline(
  supabase: ReturnType<typeof createClient>,
  inicio: Date,
  fim: Date
): Promise<MetricasPipeline> {
  const inicioStr = inicio.toISOString().split('T')[0]
  const fimStr = fim.toISOString().split('T')[0]

  // Tentar buscar da view materializada primeiro
  const { data: mvData, error: mvError } = await supabase
    .from('mv_pipeline_metrics')
    .select('*')
    .gte('data', inicioStr)
    .lte('data', fimStr)

  if (!mvError && mvData && mvData.length > 0) {
    // Agregar dados da view materializada
    const agregado = mvData.reduce(
      (acc, row) => ({
        mensagensTotal: acc.mensagensTotal + (row.mensagens_total || 0),
        mensagensProcessadas: acc.mensagensProcessadas + (row.mensagens_processadas || 0),
        mensagensPassouHeuristica: acc.mensagensPassouHeuristica + (row.mensagens_passou_heuristica || 0),
        mensagensEhOferta: acc.mensagensEhOferta + (row.mensagens_eh_oferta || 0),
        vagasExtraidas: acc.vagasExtraidas + (row.vagas_extraidas || 0),
        vagasDadosOk: acc.vagasDadosOk + (row.vagas_dados_ok || 0),
        vagasDuplicadas: acc.vagasDuplicadas + (row.vagas_duplicadas || 0),
        vagasImportadas: acc.vagasImportadas + (row.vagas_importadas || 0),
        vagasRevisao: acc.vagasRevisao + (row.vagas_revisao || 0),
        vagasDescartadas: acc.vagasDescartadas + (row.vagas_descartadas || 0),
        somaConfiancaClass: acc.somaConfiancaClass + (row.confianca_classificacao_media || 0),
        somaConfiancaExtr: acc.somaConfiancaExtr + (row.confianca_extracao_media || 0),
        countConfianca: acc.countConfianca + (row.confianca_classificacao_media ? 1 : 0),
      }),
      {
        mensagensTotal: 0,
        mensagensProcessadas: 0,
        mensagensPassouHeuristica: 0,
        mensagensEhOferta: 0,
        vagasExtraidas: 0,
        vagasDadosOk: 0,
        vagasDuplicadas: 0,
        vagasImportadas: 0,
        vagasRevisao: 0,
        vagasDescartadas: 0,
        somaConfiancaClass: 0,
        somaConfiancaExtr: 0,
        countConfianca: 0,
      }
    )

    return {
      mensagensTotal: agregado.mensagensTotal,
      mensagensPassouHeuristica: agregado.mensagensPassouHeuristica,
      mensagensEhOferta: agregado.mensagensEhOferta,
      vagasExtraidas: agregado.vagasExtraidas,
      vagasDadosOk: agregado.vagasDadosOk,
      vagasImportadas: agregado.vagasImportadas,
      vagasDuplicadas: agregado.vagasDuplicadas,
      vagasDescartadas: agregado.vagasDescartadas,
      vagasRevisao: agregado.vagasRevisao,
      confiancaClassificacaoMedia:
        agregado.countConfianca > 0 ? agregado.somaConfiancaClass / agregado.countConfianca : null,
      confiancaExtracaoMedia:
        agregado.countConfianca > 0 ? agregado.somaConfiancaExtr / agregado.countConfianca : null,
    }
  }

  // Fallback: buscar diretamente das tabelas
  return await buscarMetricasDireto(supabase, inicio, fim)
}

async function buscarMetricasDireto(
  supabase: ReturnType<typeof createClient>,
  inicio: Date,
  fim: Date
): Promise<MetricasPipeline> {
  const inicioStr = inicio.toISOString()
  const fimStr = fim.toISOString()

  // Buscar mensagens
  const { data: mensagens, error: errMsg } = await supabase
    .from('mensagens_grupo')
    .select('id, passou_heuristica, eh_oferta, confianca_classificacao')
    .gte('created_at', inicioStr)
    .lte('created_at', fimStr)

  if (errMsg) {
    throw new Error(`Erro ao buscar mensagens: ${errMsg.message}`)
  }

  // Buscar vagas
  const { data: vagas, error: errVagas } = await supabase
    .from('vagas_grupo')
    .select('id, status, dados_minimos_ok, eh_duplicada, confianca_geral')
    .gte('created_at', inicioStr)
    .lte('created_at', fimStr)

  if (errVagas) {
    throw new Error(`Erro ao buscar vagas: ${errVagas.message}`)
  }

  const msgArray = mensagens || []
  const vagasArray = vagas || []

  const mensagensTotal = msgArray.length
  const mensagensPassouHeuristica = msgArray.filter((m) => m.passou_heuristica).length
  const mensagensEhOferta = msgArray.filter((m) => m.eh_oferta).length

  const vagasExtraidas = vagasArray.length
  const vagasDadosOk = vagasArray.filter((v) => v.dados_minimos_ok).length
  const vagasImportadas = vagasArray.filter((v) => v.status === 'importada').length
  const vagasDuplicadas = vagasArray.filter((v) => v.eh_duplicada).length
  const vagasDescartadas = vagasArray.filter((v) => v.status === 'descartada').length
  const vagasRevisao = vagasArray.filter((v) => v.status === 'revisao').length

  const confiancasClass = msgArray
    .filter((m) => m.confianca_classificacao != null)
    .map((m) => m.confianca_classificacao as number)
  const confiancasExtr = vagasArray
    .filter((v) => v.confianca_geral != null)
    .map((v) => v.confianca_geral as number)

  return {
    mensagensTotal,
    mensagensPassouHeuristica,
    mensagensEhOferta,
    vagasExtraidas,
    vagasDadosOk,
    vagasImportadas,
    vagasDuplicadas,
    vagasDescartadas,
    vagasRevisao,
    confiancaClassificacaoMedia:
      confiancasClass.length > 0
        ? confiancasClass.reduce((a, b) => a + b, 0) / confiancasClass.length
        : null,
    confiancaExtracaoMedia:
      confiancasExtr.length > 0
        ? confiancasExtr.reduce((a, b) => a + b, 0) / confiancasExtr.length
        : null,
  }
}

// =============================================================================
// HANDLER
// =============================================================================

export async function GET(request: NextRequest) {
  try {
    // 1. Validar parametros
    const searchParams = Object.fromEntries(request.nextUrl.searchParams)
    const validacao = querySchema.safeParse(searchParams)

    if (!validacao.success) {
      return NextResponse.json(
        {
          error: 'VALIDATION_ERROR',
          message: 'Parametros invalidos',
          details: validacao.error.flatten().fieldErrors,
        },
        { status: 400 }
      )
    }

    const { period, startDate, endDate } = validacao.data

    // 2. Calcular periodo
    const { inicio, fim, dias } = calcularPeriodo(period, startDate, endDate)

    // 3. Buscar dados
    const supabase = createClient()
    const metricas = await buscarMetricasPipeline(supabase, inicio, fim)

    // 4. Construir etapas do funil
    const base = metricas.mensagensTotal
    const etapas: PipelineEtapa[] = [
      {
        id: 'mensagens',
        nome: 'Mensagens Recebidas',
        valor: metricas.mensagensTotal,
        percentual: 100,
      },
      {
        id: 'heuristica',
        nome: 'Passou Heuristica',
        valor: metricas.mensagensPassouHeuristica,
        percentual: calcularPercentual(metricas.mensagensPassouHeuristica, base),
      },
      {
        id: 'ofertas',
        nome: 'Classificadas como Oferta',
        valor: metricas.mensagensEhOferta,
        percentual: calcularPercentual(metricas.mensagensEhOferta, base),
      },
      {
        id: 'extraidas',
        nome: 'Vagas Extraidas',
        valor: metricas.vagasExtraidas,
        percentual: calcularPercentual(metricas.vagasExtraidas, base),
      },
      {
        id: 'validadas',
        nome: 'Dados Minimos OK',
        valor: metricas.vagasDadosOk,
        percentual: calcularPercentual(metricas.vagasDadosOk, base),
      },
      {
        id: 'importadas',
        nome: 'Vagas Importadas',
        valor: metricas.vagasImportadas,
        percentual: calcularPercentual(metricas.vagasImportadas, base),
      },
    ]

    // 5. Calcular taxas de conversao
    const conversoes: PipelineConversoes = {
      mensagemParaOferta: calcularTaxaConversao(metricas.mensagensEhOferta, metricas.mensagensTotal),
      ofertaParaExtracao: calcularTaxaConversao(metricas.vagasExtraidas, metricas.mensagensEhOferta),
      extracaoParaImportacao: calcularTaxaConversao(metricas.vagasImportadas, metricas.vagasExtraidas),
      totalPipeline: calcularTaxaConversao(metricas.vagasImportadas, metricas.mensagensTotal),
    }

    // 6. Calcular perdas
    const perdas: PipelinePerdas = {
      duplicadas: metricas.vagasDuplicadas,
      descartadas: metricas.vagasDescartadas,
      revisao: metricas.vagasRevisao,
      semDadosMinimos: metricas.vagasExtraidas - metricas.vagasDadosOk,
    }

    // 7. Montar response
    const response: PipelineResponse = {
      periodo: {
        inicio: inicio.toISOString().split('T')[0],
        fim: fim.toISOString().split('T')[0],
        dias,
      },
      funil: {
        etapas,
        conversoes,
      },
      perdas,
      qualidade: {
        confiancaClassificacaoMedia: metricas.confiancaClassificacaoMedia
          ? Math.round(metricas.confiancaClassificacaoMedia * 100) / 100
          : null,
        confiancaExtracaoMedia: metricas.confiancaExtracaoMedia
          ? Math.round(metricas.confiancaExtracaoMedia * 100) / 100
          : null,
      },
      updatedAt: new Date().toISOString(),
    }

    return NextResponse.json(response)
  } catch (error) {
    console.error('[Market Intelligence Pipeline] Erro:', error)

    return NextResponse.json(
      {
        error: 'INTERNAL_ERROR',
        message: 'Erro interno ao processar requisicao',
      },
      { status: 500 }
    )
  }
}
```

---

## Testes

### Arquivo: `dashboard/__tests__/api/market-intelligence/pipeline.test.ts`

```typescript
/**
 * Testes de Integracao - API Market Intelligence Pipeline
 */

import { GET } from '@/app/api/market-intelligence/pipeline/route'
import { NextRequest } from 'next/server'
import { createClient } from '@/lib/supabase/server'

// Mock do Supabase
jest.mock('@/lib/supabase/server', () => ({
  createClient: jest.fn(),
}))

const mockSupabase = {
  from: jest.fn().mockReturnThis(),
  select: jest.fn().mockReturnThis(),
  gte: jest.fn().mockReturnThis(),
  lte: jest.fn().mockReturnThis(),
}

describe('API /api/market-intelligence/pipeline', () => {
  beforeEach(() => {
    jest.clearAllMocks()
    ;(createClient as jest.Mock).mockReturnValue(mockSupabase)
  })

  describe('Validacao de Parametros', () => {
    it('deve aceitar request sem parametros (usa defaults)', async () => {
      mockSupabase.lte.mockResolvedValueOnce({
        data: [
          {
            mensagens_total: 1000,
            mensagens_passou_heuristica: 400,
            mensagens_eh_oferta: 300,
            vagas_extraidas: 200,
            vagas_dados_ok: 180,
            vagas_importadas: 150,
            vagas_duplicadas: 20,
            vagas_descartadas: 10,
            vagas_revisao: 20,
          },
        ],
        error: null,
      })

      const request = new NextRequest('http://localhost/api/market-intelligence/pipeline')
      const response = await GET(request)

      expect(response.status).toBe(200)
      const data = await response.json()
      expect(data.periodo.dias).toBe(30)
    })

    it('deve aceitar period=7d', async () => {
      mockSupabase.lte.mockResolvedValueOnce({ data: [], error: null })
      mockSupabase.lte.mockResolvedValueOnce({ data: [], error: null })
      mockSupabase.lte.mockResolvedValueOnce({ data: [], error: null })

      const request = new NextRequest('http://localhost/api/market-intelligence/pipeline?period=7d')
      const response = await GET(request)

      expect(response.status).toBe(200)
      const data = await response.json()
      expect(data.periodo.dias).toBe(7)
    })

    it('deve rejeitar period invalido', async () => {
      const request = new NextRequest('http://localhost/api/market-intelligence/pipeline?period=invalid')
      const response = await GET(request)

      expect(response.status).toBe(400)
      const data = await response.json()
      expect(data.error).toBe('VALIDATION_ERROR')
    })

    it('deve aceitar periodo customizado', async () => {
      mockSupabase.lte.mockResolvedValueOnce({ data: [], error: null })
      mockSupabase.lte.mockResolvedValueOnce({ data: [], error: null })
      mockSupabase.lte.mockResolvedValueOnce({ data: [], error: null })

      const request = new NextRequest(
        'http://localhost/api/market-intelligence/pipeline?period=custom&startDate=2024-01-01&endDate=2024-01-15'
      )
      const response = await GET(request)

      expect(response.status).toBe(200)
      const data = await response.json()
      expect(data.periodo.inicio).toBe('2024-01-01')
      expect(data.periodo.fim).toBe('2024-01-15')
    })
  })

  describe('Response Structure - Funil', () => {
    beforeEach(() => {
      mockSupabase.lte.mockResolvedValue({
        data: [
          {
            mensagens_total: 1000,
            mensagens_passou_heuristica: 400,
            mensagens_eh_oferta: 300,
            vagas_extraidas: 200,
            vagas_dados_ok: 180,
            vagas_importadas: 150,
            vagas_duplicadas: 20,
            vagas_descartadas: 10,
            vagas_revisao: 20,
            confianca_classificacao_media: 0.87,
            confianca_extracao_media: 0.82,
          },
        ],
        error: null,
      })
    })

    it('deve retornar todas as etapas do funil', async () => {
      const request = new NextRequest('http://localhost/api/market-intelligence/pipeline')
      const response = await GET(request)
      const data = await response.json()

      expect(data.funil.etapas).toHaveLength(6)
      expect(data.funil.etapas[0].id).toBe('mensagens')
      expect(data.funil.etapas[1].id).toBe('heuristica')
      expect(data.funil.etapas[2].id).toBe('ofertas')
      expect(data.funil.etapas[3].id).toBe('extraidas')
      expect(data.funil.etapas[4].id).toBe('validadas')
      expect(data.funil.etapas[5].id).toBe('importadas')
    })

    it('deve ter estrutura correta em cada etapa', async () => {
      const request = new NextRequest('http://localhost/api/market-intelligence/pipeline')
      const response = await GET(request)
      const data = await response.json()

      const etapa = data.funil.etapas[0]
      expect(etapa).toHaveProperty('id')
      expect(etapa).toHaveProperty('nome')
      expect(etapa).toHaveProperty('valor')
      expect(etapa).toHaveProperty('percentual')
      expect(typeof etapa.valor).toBe('number')
      expect(typeof etapa.percentual).toBe('number')
    })

    it('deve ter percentual 100 na primeira etapa', async () => {
      const request = new NextRequest('http://localhost/api/market-intelligence/pipeline')
      const response = await GET(request)
      const data = await response.json()

      expect(data.funil.etapas[0].percentual).toBe(100)
    })

    it('deve ter percentuais decrescentes', async () => {
      const request = new NextRequest('http://localhost/api/market-intelligence/pipeline')
      const response = await GET(request)
      const data = await response.json()

      for (let i = 1; i < data.funil.etapas.length; i++) {
        expect(data.funil.etapas[i].percentual).toBeLessThanOrEqual(
          data.funil.etapas[i - 1].percentual
        )
      }
    })
  })

  describe('Response Structure - Conversoes', () => {
    beforeEach(() => {
      mockSupabase.lte.mockResolvedValue({
        data: [
          {
            mensagens_total: 1000,
            mensagens_passou_heuristica: 400,
            mensagens_eh_oferta: 300,
            vagas_extraidas: 200,
            vagas_dados_ok: 180,
            vagas_importadas: 150,
          },
        ],
        error: null,
      })
    })

    it('deve retornar taxas de conversao', async () => {
      const request = new NextRequest('http://localhost/api/market-intelligence/pipeline')
      const response = await GET(request)
      const data = await response.json()

      expect(data.funil.conversoes).toHaveProperty('mensagemParaOferta')
      expect(data.funil.conversoes).toHaveProperty('ofertaParaExtracao')
      expect(data.funil.conversoes).toHaveProperty('extracaoParaImportacao')
      expect(data.funil.conversoes).toHaveProperty('totalPipeline')
    })

    it('deve calcular mensagemParaOferta corretamente', async () => {
      const request = new NextRequest('http://localhost/api/market-intelligence/pipeline')
      const response = await GET(request)
      const data = await response.json()

      // 300 ofertas / 1000 mensagens = 30%
      expect(data.funil.conversoes.mensagemParaOferta).toBe(30)
    })

    it('deve calcular ofertaParaExtracao corretamente', async () => {
      const request = new NextRequest('http://localhost/api/market-intelligence/pipeline')
      const response = await GET(request)
      const data = await response.json()

      // 200 extraidas / 300 ofertas = 66.7%
      expect(data.funil.conversoes.ofertaParaExtracao).toBeCloseTo(66.7, 0)
    })

    it('deve calcular totalPipeline corretamente', async () => {
      const request = new NextRequest('http://localhost/api/market-intelligence/pipeline')
      const response = await GET(request)
      const data = await response.json()

      // 150 importadas / 1000 mensagens = 15%
      expect(data.funil.conversoes.totalPipeline).toBe(15)
    })
  })

  describe('Response Structure - Perdas', () => {
    beforeEach(() => {
      mockSupabase.lte.mockResolvedValue({
        data: [
          {
            mensagens_total: 1000,
            vagas_extraidas: 200,
            vagas_dados_ok: 150,
            vagas_importadas: 120,
            vagas_duplicadas: 30,
            vagas_descartadas: 20,
            vagas_revisao: 30,
          },
        ],
        error: null,
      })
    })

    it('deve retornar perdas do pipeline', async () => {
      const request = new NextRequest('http://localhost/api/market-intelligence/pipeline')
      const response = await GET(request)
      const data = await response.json()

      expect(data.perdas).toHaveProperty('duplicadas')
      expect(data.perdas).toHaveProperty('descartadas')
      expect(data.perdas).toHaveProperty('revisao')
      expect(data.perdas).toHaveProperty('semDadosMinimos')
    })

    it('deve calcular semDadosMinimos corretamente', async () => {
      const request = new NextRequest('http://localhost/api/market-intelligence/pipeline')
      const response = await GET(request)
      const data = await response.json()

      // 200 extraidas - 150 dados ok = 50 sem dados minimos
      expect(data.perdas.semDadosMinimos).toBe(50)
    })
  })

  describe('Response Structure - Qualidade', () => {
    it('deve retornar metricas de qualidade', async () => {
      mockSupabase.lte.mockResolvedValue({
        data: [
          {
            mensagens_total: 1000,
            confianca_classificacao_media: 0.87,
            confianca_extracao_media: 0.82,
          },
        ],
        error: null,
      })

      const request = new NextRequest('http://localhost/api/market-intelligence/pipeline')
      const response = await GET(request)
      const data = await response.json()

      expect(data.qualidade).toHaveProperty('confiancaClassificacaoMedia')
      expect(data.qualidade).toHaveProperty('confiancaExtracaoMedia')
      expect(data.qualidade.confiancaClassificacaoMedia).toBe(0.87)
      expect(data.qualidade.confiancaExtracaoMedia).toBe(0.82)
    })

    it('deve retornar null quando nao ha dados de confianca', async () => {
      mockSupabase.lte.mockResolvedValue({
        data: [{ mensagens_total: 1000 }],
        error: null,
      })

      const request = new NextRequest('http://localhost/api/market-intelligence/pipeline')
      const response = await GET(request)
      const data = await response.json()

      expect(data.qualidade.confiancaClassificacaoMedia).toBeNull()
      expect(data.qualidade.confiancaExtracaoMedia).toBeNull()
    })
  })

  describe('Tratamento de Erros', () => {
    it('deve retornar 500 quando banco falha', async () => {
      mockSupabase.lte.mockResolvedValue({
        data: null,
        error: { message: 'Database error' },
      })

      const request = new NextRequest('http://localhost/api/market-intelligence/pipeline')
      const response = await GET(request)

      expect(response.status).toBe(500)
      const data = await response.json()
      expect(data.error).toBe('INTERNAL_ERROR')
    })
  })

  describe('Edge Cases', () => {
    it('deve lidar com divisao por zero', async () => {
      mockSupabase.lte.mockResolvedValue({
        data: [
          {
            mensagens_total: 0,
            mensagens_eh_oferta: 0,
            vagas_extraidas: 0,
            vagas_importadas: 0,
          },
        ],
        error: null,
      })

      const request = new NextRequest('http://localhost/api/market-intelligence/pipeline')
      const response = await GET(request)

      expect(response.status).toBe(200)
      const data = await response.json()
      expect(data.funil.conversoes.mensagemParaOferta).toBe(0)
      expect(data.funil.conversoes.totalPipeline).toBe(0)
    })

    it('deve agregar multiplos dias corretamente', async () => {
      mockSupabase.lte.mockResolvedValue({
        data: [
          { mensagens_total: 500, vagas_importadas: 50 },
          { mensagens_total: 500, vagas_importadas: 50 },
        ],
        error: null,
      })

      const request = new NextRequest('http://localhost/api/market-intelligence/pipeline')
      const response = await GET(request)
      const data = await response.json()

      expect(data.funil.etapas[0].valor).toBe(1000)
      expect(data.funil.etapas[5].valor).toBe(100)
    })
  })
})
```

---

## Definition of Done (DoD)

### Checklist Obrigatorio

- [ ] Arquivo criado em `app/api/market-intelligence/pipeline/route.ts`
- [ ] Validacao com Zod implementada
- [ ] 6 etapas do funil retornadas
- [ ] Taxas de conversao calculadas
- [ ] Metricas de perda retornadas
- [ ] Metricas de qualidade retornadas
- [ ] Fallback para tabelas originais quando MV vazia
- [ ] Testes de integracao escritos
- [ ] Cobertura de testes >= 80%
- [ ] Endpoint responde em < 500ms
- [ ] Zero erros de TypeScript

### Comandos de Verificacao

```bash
# Rodar testes
npm run test -- __tests__/api/market-intelligence/pipeline.test.ts

# Verificar cobertura
npm run test -- __tests__/api/market-intelligence/pipeline.test.ts --coverage

# Testar endpoint
curl "http://localhost:3000/api/market-intelligence/pipeline?period=30d"
```

---

## Criterios de Aceitacao

| ID | Criterio | Verificacao |
|----|----------|-------------|
| AC1 | Endpoint existe | GET /api/market-intelligence/pipeline retorna 200 |
| AC2 | Valida parametros | period=invalid retorna 400 |
| AC3 | Retorna 6 etapas | funil.etapas tem length 6 |
| AC4 | Percentuais corretos | Primeira etapa = 100%, demais <= anterior |
| AC5 | Conversoes calculadas | funil.conversoes tem 4 taxas |
| AC6 | Perdas retornadas | perdas tem 4 categorias |
| AC7 | Qualidade retornada | qualidade tem 2 metricas |
| AC8 | Testes passam | npm run test passa |
| AC9 | Cobertura >= 80% | Coverage report >= 80% |

---

## Notas para o Desenvolvedor

1. **Ordem das Etapas**: Manter sempre a mesma ordem para consistencia visual
2. **Percentuais**: Sempre relativos a primeira etapa (mensagens)
3. **Divisao por Zero**: Tratar retornando 0 em vez de NaN/Infinity
4. **Confianca**: Valores entre 0 e 1, arredondar para 2 casas decimais
5. **Agregacao**: Somar valores de multiplos dias, fazer media das confiancas
